<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Index</title>

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
    <link rel="stylesheet" href="../assets/bootstrap/css/bootstrap.min.css" />
    <link rel="stylesheet" href="./assets/styles/site.css" />
  </head>
  <body>
    <nav class="navbar navbar-expand-lg bg-light">
      <div class="container-fluid">
        <a class="navbar-brand" href="../index.html">Home</a>
      </div>
    </nav>
    <div class="container">
      <h1>TypeScript</h1>
      <section class="navlinks">
        <ul>
          <li><a href="./angular/angularcli.html#commands">Commands</a></li>
        </ul>
      </section>
      <section>
        <ul>
          <li>
            Adds static typing to JavaScript/ECMAScript
            <ul>
              <li>Checks your code as you write it for errors</li>
              <li>
                Makes suggestions and provides intellisense, code completion,
                and quick fixes
              </li>
              <li>
                Allows refactoring and navigation features to jump to
                definitions or finding references
              </li>
              <li>
                It is a structurally typed type system since it only cares that
                an object has the expected properties and methods
              </li>
            </ul>
          </li>
          <li>
            JS uses dynamic typing - types are assigned at runtime, so certain
            errors only show themselves at runtime
            <ul>
              <li>
                This shifts error checking from runtime (when JS usually detects
                errors) to design time
              </li>
              <li>
                JS relies on things like the <code>typeof</code> operator to
                verify type
              </li>
            </ul>
          </li>
          <li>
            This prevents such as
            <ul>
              <li>
                Calling methods or using properties on an object that do not
                exist
              </li>
              <li>Calling methods on objects that don't exist</li>
              <li>Attempting operations on variables of the wrong type</li>
              <li>Incorrectly spelling a method call</li>
            </ul>
          </li>
        </ul>
      </section>

      <h2>Compiler</h2>
      <section>
        <ul>
          <li>The TypeScript compiler is tsc</li>
          <li>
            Install it globally from npm with
            <code>npm install -g typescript</code>
          </li>
          <li>
            <code>tsc hello.tsc</code>
            <ul>
              <li>
                This will generate a hello.js file beside the TypeScript file
              </li>
              <li>
                This will attempt to preserve comments, tabbing, and generally
                try to look like something a human wrote
              </li>
            </ul>
          </li>
          <li>
            TypeScript is flexible enough with its error checking to not get in
            the way
            <ul>
              <li>
                For instance, if you port an existing JavaScript file to a
                TypeScript file, the compiler will not enforce aggressive type
                checks
              </li>
              <li>
                You can adjust the compiler behavior in the tsconfig.ts file
              </li>
            </ul>
          </li>
          <li>
            Performs the following transformations
            <ul>
              <li>
                Strips out TypeScript specific items such as type annotations
              </li>
              <li>
                Downlevels features that are not available in the targetted
                version of ECMAScript (such as swapping string interpolation for
                concatentation)
              </li>
            </ul>
          </li>
          <li>
            Strictness of the compiler can be adjusted in the tsconfig.ts files
            <ul>
              <li>
                <code>"strict": true</code> toggles all checks on
                simulataneously (but others can be adjusted individually)
              </li>
              <li>
                <code>noImplicitAny</code> - issues errors on variables whose
                type is implicity typed as any
              </li>
              <li>
                <code>strictNullChecks</code> - prevents null and undefined
                variable assignments, such as default value assignments
              </li>
            </ul>
          </li>
        </ul>
      </section>

      <h2>Types</h2>
      <section>
        <ul>
          <li>
            Any
            <ul>
              <li>
                TS specifal type when you dont want a particular value to
                trigger typechecking errors
              </li>
              <li>
                Allows anythign syntactically legal - can access any properties,
                function, assign to and from any other item typed as any
              </li>
            </ul>
          </li>
          <li>
            JS Primitives
            <ul>
              <li>
                TS contains commonly used primitives in JS, string, number, and
                Boolean
              </li>
              <li>
                There are upper case versions of these, but you should not use
                them when typing
              </li>
            </ul>
          </li>
          <li>
            Arrays
            <ul>
              <li>
                Can be typed using <code>string[]</code> or
                <code>Array&gt;string&lt;</code>
              </li>
            </ul>
          </li>
          <li>
            Object types
            <ul>
              <li>
                To define an object type, list the properties and their types
                <div class="card">
                  <div class="card-body">
                    <code>
                      function printName(obj: { first: string; last?: string })
                      {"
                    </code>
                  </div>
                </div>
              </li>
              <li>
                Optional properties can be marked with a ?. Make sure to check
                for undefined or use a safe navigation operatior when using
                these.
                <div class="card">
                  <div class="card-body">
                    <code> console.log(obj.last?.toUpperCase());" </code>
                  </div>
                </div>
              </li>
            </ul>
          </li>
          <li>
            null
            <ul>
              <li>Signals absent value</li>
              <li>
                When stringNullChecks is on, you must test thse values before
                using methods or properties on the value
              </li>
              <li>
                Can use the non-null assertion operator to tell the compiler
                that a value cannot be null. TS will not check this when
                applied.
                <div class="card">
                  <div class="card-body">
                    <code> console.log(x!.toFixed());" </code>
                  </div>
                </div>
              </li>
            </ul>
          </li>
          <li>
            undefined
            <ul>
              <li>Signals uninitialized value</li>
              <li>
                Can use the non-null assertion operator to tell the compiler
                that a value cannot be null. TS will not check this when
                applied.
              </li>
            </ul>
          </li>
        </ul>
      </section>

      <h2>Typing</h2>
      <section>
        <ul>
          <li>
            TypeScript can often infer types that are missing
            <ul>
              <li>
                It can figure out that <code>msg</code> is a string from
                <code>let msg = "hello there"</code>
              </li>
              <li>
                You can skip type annotations when TypeScript can correctly
                infer them
              </li>
            </ul>
          </li>
          <li>
            Types can be explicity assigned like these examples
            <ul>
              <li>
                Function with typed parameters and return type
                <div class="card">
                  <div class="card-body">
                    <code>
                      " function greet(person: string, date: Date): string { ...
                    </code>
                  </div>
                </div>
              </li>
            </ul>
          </li>
          <li>
            Contextual typing occurs when the context that the function occured
            within informs what types should be used
            <ul>
              <li>
                This pops up in places like annonymous functions and arrow
                functions
              </li>
            </ul>
            <img src="../../assets/typescript-types-1.png" />
          </li>
          <li>
            Function return types can be configured to return more than one type
          </li>
          <li>
            This is useful if you want to either return a data object or an
            custom error object (in the event of an error)
          </li>
          <li>
            Union types
            <ul>
              <li>A type formed from two or more other types</li>
              <li>Values may be any one of those types</li>
              <li>Constiuant types are called members</li>
              <li>
                Operations are only allowed if it is valid for every member of
                the union
              </li>
              <li>
                Narrowing (checking for type using typeof) can help TypeScript
                infer the correct type
              </li>
            </ul>
            <div>
              Example of a simple union type
              <div class="card">
                <div class="card-body">
                  <code>
                    getAllBooks(): Observable&lt;Book&#91;&#93; |
                    CustomError&gt; { ...."
                  </code>
                </div>
              </div>
            </div>
            <div>
              Example of a function that can accept a union Type - this will
              trigger an error since number does not have a toUpperCase method
              <div class="card">
                <div class="card-body">
                  <code>
                    function printId(id: number | string) {&#10;
                    console.log(id.toUpperCase());&#10;}"
                  </code>
                </div>
              </div>
            </div>
            <div>
              Example of using narrowing to prevent the above error
              <div class="card">
                <div class="card-body">
                  <code>
                    function printId(id: number | string) {&#10; if (typeof id
                    === &quot;string&quot;) {&#10; // In this branch, id is of
                    type 'string'&#10; console.log(id.toUpperCase());&#10; }
                    else {&#10; // Here, id is of type 'number'&#10;
                    console.log(id);&#10; }&#10;}"
                  </code>
                </div>
              </div>
            </div>
            <div>
              Example of a function that could return an error type or a data
              type
            </div>
            <div class="card">
              <div class="card-body">
                <code>
                  getAllBooks(): Observable&lt;Book&#91;&#93; | CustomError&gt;
                  { ...."
                </code>
              </div>
            </div>
          </li>
        </ul>
      </section>

      <h2>Type Aliases</h2>
      <section>
        <ul>
          <li>A name for a type</li>
          <li>
            Example
            <div class="card">
              <div class="card-body">
                <code>
                  type Point = {&#10; x: number;&#10; y: number;&#10;};"
                </code>
              </div>
            </div>
          </li>
        </ul>
        <li>
          A type alias for a union type
          <div class="card">
            <div class="card-body">
              <code> type ID = number | string;" </code>
            </div>
          </div>
        </li>
      </section>

      <h2>Interfaces</h2>
      <section>
        <ul>
          <li>
            Another way to name an object type (in addition to aliases)
            <div class="card">
              <div class="card-body">
                <code>
                  interface Point {&#10; x: number;&#10; y: number;&#10;}"
                </code>
              </div>
            </div>
          </li>
          <li>Interfaces can extend other interfaces</li>
          <li>
            May only be used to declare the shapes of objects, not rename
            primitives
          </li>
          <li>
            Very similar to aliases. The main difference is that a type cannot
            be re-opened to add new properties, while an interface is always
            extendable
            <img src="../../assets//typescript-interfaces-1.png" />
          </li>
        </ul>
      </section>

      <h2>Type Assertions</h2>
      <section>
        <ul>
          <li>
            Uset this to give TypeScript information about a type of a value
            that the compiler cannot know about
          </li>
          <li>
            This gives a more specific HTMLElement type (TS figures out it is a
            HTMLElement, but you know it is a HTMLCanvasElement by the id)
            <div class="card">
              <div class="card-body">
                <code>
                  code='const myCanvas = document.getElementById("main_canvas")
                  as HTMLCanvasElement;'
                </code>
              </div>
            </div>
          </li>
          <li>
            Allows type assertions which convert to a more specific or less
            specific version of a type
          </li>
        </ul>
      </section>

      <h2>Literal Types</h2>
      <section>
        <ul>
          <li>
            Allows you to refer to specific strings and numbers in type
            positions
          </li>
          <li>
            One example where this is useful is defining a function that only
            accepts a certain set of known values
            <div class="card">
              <div class="card-body">
                <code>
                  code='function printText(s: string, alignment: "left" |
                  "right" | "center") { ...'
                </code>
              </div>
            </div>
          </li>
          <li>
            Another example is a function that only returns specific numbers
            <div class="card">
              <div class="card-body">
                <code>
                  function compare(a: string, b: string): -1 | 0 | 1 {&#10;
                  return a === b ? 0 : a &gt; b ? 1 : -1;&#10;}"
                </code>
              </div>
            </div>
          </li>
          <li>
            There are two boolean literal types, true and false
            <ul>
              <li>
                The boolean type is just an alias for the union true | false
              </li>
            </ul>
          </li>
        </ul>
      </section>

      <h2>Type Declarations</h2>
      <section>
        <ul>
          <li>TypeScript file that ends with a .d.ts extension</li>
          <li>
            Only contain type related code, not logical code
            <ul>
              <li>Do not produce .js outputs</li>
              <li>
                Only purpose is to provide type information to the developer
              </li>
              <li>Only useful during development for typechecking</li>
            </ul>
          </li>
          <li>
            TypeScript includes declaration files for all of the standardized
            built in APIs available in JavaScript runtimes
            <ul>
              <li>
                This includes things such as
                <ul>
                  <li>
                    Methods and properties of built in types like string or
                    function
                  </li>
                  <li>Top level names like Math and Object</li>
                  <li>
                    DOM APIs = things available when running inside the browser
                    such as window and documents
                  </li>
                </ul>
              </li>
              <li>
                These files are named with the pattern lib.[something].d.ts
              </li>
              <li>
                The target compilation setting determines which are available to
                use
              </li>
            </ul>
          </li>
          <li>
            Extenal definitions are useful when working with non-standard APIs
            <ul>
              <li>
                Bundled types - type declarations are frequently bundled into
                npm packages
              </li>
              <li>
                DefinatelyTyped repository
                <ul>
                  <li>
                    Massive repository containing declaration files for
                    thousands of libraries
                  </li>
                  <li>
                    These are automatically published to npm under the @types
                    scope
                  </li>
                  <li>
                    Name is alwasy the same as the associated package -
                    @types/react
                  </li>
                </ul>
              </li>
              <li>If no typing files exists, you can write your own</li>
            </ul>
          </li>
        </ul>
      </section>

      <h2>Enums</h2>
      <section>
        <div>
          Situations where enums should be used:
          <ul>
            <li>You need a user defined constants system</li>
            <li>
              When there are distinct values that can be seen as constants
            </li>
            <li>
              In places where strings or constants need to be represented in a
              variable
            </li>
          </ul>
          Situations where enums should not be used:
          <ul>
            <li>If you plan on reassinging or chinig the enum member values</li>
            <li>Good for finite items, not so good for dynamic values</li>
            <li>Cannot be used for variables</li>
          </ul>
        </div>
        <div>
          Enums can be reverse mapped, so you can access the enum name as well
          as the enum value
          <div class="card">
            <div class="card-body">
              <code>
                code='enum Weekend {&#10; Friday = 1,&#10; Saturday,&#10;
                Sunday&#10;}&#10;Weekend.Saturday // returns
                2&#10;Weekend&#91;"Saturday"&#93;; // returns
                2&#10;Weekend&#91;2&#93;; // returns Saturday'
              </code>
            </div>
          </div>
        </div>
        <div>
          There are three types:
          <div>
            Numeric
            <ul>
              <li>This is the default.</li>
              <li>Items in the enum are interpretted as numbers.</li>
              <li>These can be implicitly or explicitly defined.</li>
              <li>
                Enums can be declared as constant for a performance boost.
              </li>
            </ul>
            <div class="card">
              <div class="card-body">
                <code>
                  const enum Weekend1 {&#10; Friday,&#10; Saturday,&#10;
                  Sunday&#10;}&#10;&#10;enum Weekend2 {&#10; Friday = 1,&#10;
                  Saturday,&#10; Sunday&#10;}&#10;&#10;enum Weekend3 {&#10;
                  Friday = 1,&#10; Saturday = 13,&#10; Sunday =
                  5&#10;}&#10;&#10;enum Weekend {&#10; Friday = 1,&#10; Saturday
                  = getDate('TGIF'),&#10; Sunday = Saturday *
                  40&#10;}&#10;&#10;function getDate(day : string): number
                  {&#10; if (day === 'TGIF') {&#10; return 3;&#10; }&#10;}"
                </code>
              </div>
            </div>
          </div>
          <div>
            String
            <div class="card">
              <div class="card-body">
                <code>
                  enum Weekend {&#10; Friday = 'FRIDAY',&#10; Saturday =
                  'SATURDAY',&#10; Sunday = 'SUNDAY'&#10;}"
                </code>
              </div>
            </div>
          </div>
          <div>
            Heterogeneous
            <ul>
              <li>Consist of a mixture of strings and numbers.</li>
              <li>Limited ue cases and generally not recommended to use.</li>
            </ul>
            <div class="card">
              <div class="card-body">
                <code>
                  enum Weekend {&#10; Friday = 'FRIDAY',&#10; Saturday = 1,&#10;
                  Sunday = 2&#10;}"
                </code>
              </div>
            </div>
          </div>
        </div>
      </section>

      <h2>Definite Assignment Assertions</h2>
      <section>
        <ul>
          <li>
            Tells TypeScript that an instance property or variable declaration
            will be assigned to, even if it cannot detect that it will be
          </li>
          <li>
            With it, TypeScript will not throw an error that the variable has
            not been initialized
          </li>
        </ul>
        <div>
          The following will cause an error: Variable 'x' is used before being
          assigned.
        </div>
        <div class="card">
          <div class="card-body">
            <code>
              let x: number;&#10;initialize();&#10;console.log(x +
              x);&#10;&#10;function initialize() {&#10; x = 10;&#10;}"
            </code>
          </div>
        </div>
        <div>
          Adding the ! operator will prevent TypeScript from triggering the
          error
        </div>
        <div class="card">
          <div class="card-body">
            <code>
              let x: number;&#10;initialize();&#10;console.log(x! +
              x!);&#10;&#10;function initialize() {&#10; x = 10;&#10;}"
            </code>
          </div>
        </div>
      </section>

      <h2>Object Types</h2>
      <section>
        <li>
          Three ways to create an object in TypeScript
          <ul>
            <li>
              Can be annonymous
              <div class="card">
                <div class="card-body">
                  <code>
                    code='function greet(person: { name: string; age: number })
                    {&#10; return "Hello " + person.name;&#10;}'
                  </code>
                </div>
              </div>
            </li>
            <li>
              Can also use an interface
              <div class="card">
                <div class="card-body">
                  <code>
                    code='interface Person {&#10; name: string;&#10; age:
                    number;&#10;}&#10; &#10;function greet(person: Person)
                    {&#10; return "Hello " + person.name;&#10;}'
                  </code>
                </div>
              </div>
            </li>
            <li>
              Can also use a type aliases
              <div class="card">
                <div class="card-body">
                  <code>
                    code='type Person = {&#10; name: string;&#10; age:
                    number;&#10;};&#10; &#10;function greet(person: Person)
                    {&#10; return "Hello " + person.name;&#10;}'
                  </code>
                </div>
              </div>
            </li>
            <li>
              In each of the three styles written above, the parameter object
              must have a string property named name and a number property named
              age
            </li>
          </ul>
        </li>
        <li>
          Properties can be marked as optional using a question mark
          <ul>
            <ul>
              If you attempt to read from this property, TypeScript will warn
              you it is potentially undefined
            </ul>
            <li>
              Basically says if the property is set, it better have a specific
              type
              <div class="card">
                <div class="card-body">
                  <code>
                    interface PaintOptions {&#10; shape: Shape;&#10; xPos?:
                    number;&#10; yPos?: number;&#10;}"
                  </code>
                </div>
              </div>
            </li>
          </ul>
        </li>
        <li>
          Properties can be marked as readonly
          <ul>
            <li>No effect at runtime</li>
            <li>Cannot be written to during type checking</li>
            <li>
              You can still modify internal contents (like adding items to a
              readonly array), not it is not totally immutable
            </li>
          </ul>
        </li>
      </section>
    </div>
    <script src="../assets/bootstrap/js/bootstrap.bundle.js"></script>
  </body>
</html>
