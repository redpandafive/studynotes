<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Index</title>

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
    <link rel="stylesheet" href="../../assets/bootstrap/css/bootstrap.min.css" />
    <link rel="stylesheet" href="../../assets/styles/site.css" />
  </head>

  <body>
    <nav class="navbar navbar-expand-lg bg-light">
      <div class="container-fluid">
        <a class="navbar-brand" href="../../index.html">Home</a>
      </div>
    </nav>
    <div class="container">
      <nav class="breadcrumb">
        <ol class="breadcrumb">
          <li class="breadcrumb-item"><a href="../../index.html">Home</a></li>
          <li class="breadcrumb-item">
            <a href="../index.html">Angular</a>
          </li>
          <li class="breadcrumb-item active" aria-current="page">Effects</li>
        </ol>
      </nav>

      <h1>Effects</h1>

      <section>
        <ul>
          <li>An operation that runs whenever one or more signal values change</li>
          <li>
            An essential limitation is that they can only be used in an injection context
            <ul>
              <li>This is anywhere inject can be used</li>
              <li>Effects use DestroyRef to "unsubscribe" themselves when the surrounding building block is about to be destroyed</li>
            </ul>
          </li>
          <li>
            Effects are generally not recommended to use:
            <ul>
              <li>They are powerful and flexible, but they have a lot of tradeoffs you may not realize you are making when you use them</li>
              <li>
                Before Angular 19, an error would be thrown when attempting to update a Signal within an Effect
                <ul>
                  <li>If not used carefully, you could introduce a cycle with these</li>
                  <li>This has been removed in Angular 19</li>
                </ul>
              </li>
              <li>
                Before Angular 19, they are also not guaranteed to run right when notified of a Signal change
              </li>
              <li>If you find yourself reaching for an Effect, stop and re-examine the problem to see if there is a different approach that doesn't involve using them.</li>

            </ul>
          </li>
          <li>
            Primarily intended for rendering
            <ul>
              <li>Use for rendering stuff you cannot render using data binding.</li>
              <li>
                Example use cases includes
                <ul>
                  <li>Logging</li>
                  <li>Painting on a Canvas</li>
                  <li>Custom DOM behavior that cannot be expressed via the template syntax</li>
                </ul>
              </li>
              <li>Think of this as a Observable tap operation that automatically "subscribes" to the signal</li>
            </ul>
          </li>
          <li>
            Do not use effects for propagating state
            <ul>
              <li>
                Risks include
                <ul>
                  <li>Circular updates and infinite loops</li>
                  <li>Since Angular uses auto-tracking for computed and effects, it can lead to code that is hard to maintain if used for state changes</li>
                  <li>Effects are not guaranteed to be an immediate action
                    <ul>
                      <li>They run on a schedule at some point in the future</li>
                      <li>There could be a gap in time between when the signal value is changed and when the effect is run</li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>
                Glitch = you can observe a state that doesn't sense
                <ul>
                  <li>
                    You can end up with a glitch if you are using effects for synchronization
                  </li>
                  <li>
                    Signals are glitch free; if you change a signal several times in a row (within a stack frame), only the last change is seen
                    <ul>
                      <li>This fits well for rendering, but is not suited for state modification where the signal represents an event</li>
                    </ul>
                  </li>
                </ul>
              </li>

            </ul>
          </li>
          <li>
            Comprised of
            <ul>
              <li>Effect creation function = the <code>effect()</code> function call</li>
              <li>The effect function = function that is executed when any contained signals are updated</li>
            </ul>
          </li>
        </ul>
      </section>

      <h2>Examples</h2>
      <section>
        <div>
          In this example, the value of the selectedVehicle signal will be logged to console whenever it changes
          <div class="card">
            <div class="card-body">
              <code> effect(() => console.log(this.selectedVehicle())); </code>
            </div>
          </div>
        </div>
        <div>
          <div class="card">
            <div class="card-body">
              <code>
                &lt;label attr.for=&quot;{+{someId}}&quot;&gt;
                <br />
                &lt;label &#91;attr.for&#93;=&quot;someId&quot;&gt;
                <br />
                &lt;label &#91;htmlFor&#93;=&quot;someId&quot;&gt;
              </code>
            </div>
          </div>
        </div>
      </section>
    </div>
    <script src="../../assets/bootstrap/js/bootstrap.bundle.js"></script>
  </body>
</html>
