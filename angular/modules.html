<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Index</title>
    <base href="/" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
    <link rel="stylesheet" href="./assets/bootstrap/css/bootstrap.min.css" />
    <link rel="stylesheet" href="./assets/styles/site.css" />
  </head>
  <body>
    <nav class="navbar navbar-expand-lg bg-light">
      <div class="container-fluid">
        <a class="navbar-brand" href="./">Home</a>
      </div>
    </nav>
    <div class="container">
      <nav class="breadcrumb">
        <ol class="breadcrumb">
          <li class="breadcrumb-item"><a href="../index.html">Home</a></li>
          <li class="breadcrumb-item">
            <a href="./angular/index.html">Angular</a>
          </li>
          <li class="breadcrumb-item active" aria-current="page">Modules</li>
        </ol>
      </nav>
      <h1>Modules</h1>
      <section class="navlinks">
        <ul>
          <li><a href="./angular/modules.html#basics">Basics</a></li>
          <li>
            <a href="./angular/modules.html#configuration">Configuration</a>
          </li>
          <li>
            <a href="./angular/modules.html#readability"
              >Configuration & Readability</a
            >
          </li>
          <li>
            <a href="./angular/modules.html#context"
              >Compilation Context & Readability</a
            >
          </li>
          <li>
            <a href="./angular/modules.html#builtin">Common Built-In Modules</a>
          </li>
          <li><a href="./angular/modules.html#categories">Categories</a></li>
          <li><a href="./angular/modules.html#entry">Entry Components</a></li>
          <li><a href="./angular/modules.html#feature">Feature</a></li>
          <li>
            <a href="./angular/modules.html#appvsfeature">App vs Feature</a>
          </li>
          <li><a href="./angular/modules.html#shared">Shared</a></li>
          <li>
            <a href="./angular/modules.html#lazy"
              >Lazy Loading Feature Modules</a
            >
          </li>
        </ul>
      </section>

      <h2 id="basics">Basics</h2>
      <section>
        These are the basic building blocks of an Angular application
        <ul>
          <li>Provide a compilation context for components</li>
          <li>
            Collect related code into functional sets that are meant to be used
            together, including components, services, etc.
          </li>
          <li>
            Configures the injector and the compiler and helps organize related
            things together
          </li>
          <li>
            Can import functionality from other modules and export functionality
            into others
          </li>
          <li>Allows for lazy loading to minimize code loaded at startup</li>
        </ul>

        They are not the same as ES concept of modules
        <ul>
          <li>
            In ES, each file is a module and all objects defined in the file
            belong to that module
          </li>
          <li>
            The module declares some objects to be public by marking them with
            the export key word
          </li>
          <li>
            ES uses import statements to access public objects from other
            modules
          </li>
        </ul>
        Vs JS Modules
        <ul>
          <li>
            NgModules are explicitly defined as modules, while JS modules are
            modules by being in their own files
          </li>
          <li>
            NgModules can only export the declarable classes it owns or imports
            from other modules. It doesnt declare or export any other king od
            class
          </li>
          <li>
            NgModules are mainly a template compliation context; JS modules wrap
            private details in a closure and expose only the public API we want
          </li>
        </ul>

        An app has at least one root module that enables bootstrapping of the
        application
        <ul>
          <li>Called AppModule</li>
          <li>Defined in app.module.ts</li>
          <li>Bootstrapping this module launches your application</li>
        </ul>

        Typically have one or more feature modules
      </section>

      <h2 id="configuration">Configuration</h2>
      <section>
        Declare using a class marked with the @NgModule decorator
        <ul>
          <li>
            Takes a metadata object that describes how to compile a component’s
            template and how to create an injector at run time
          </li>
          <li>
            Identifies components, directives, pipes that belong to the module
          </li>
          <ul>
            <li>These can be made public using the exports property</li>
          </ul>
        </ul>

        <li>Adds service providers to the application dependency injectors</li>
        Accepts a metadata object that includes the following properties:
        <ul>
          <li>declarations</li>
          <ul>
            <li>
              Declarable classes such as components, directives, and pipes that
              belong to the module
            </li>
            <li>
              Components should be in the declarations section of exactly one
              module of the application
            </li>
            <li>
              Should not add Module classes, Service classes, and non-Angular
              classes and objects
            </li>
          </ul>

          <li>exports</li>
          <ul>
            <li>
              Subset of the declarations that should be visible and useable in
              the component templates of other NgModules
            </li>
            <li>Private items do not need to be exported</li>
            <li>Only items that other modules will use should be exported</li>
            <li>
              Can export an entire module that effectively exports all their
              exported classes
            </li>
            <li>
              Re-exporting classes and modules is a good way to selectively
              aggregate classes from other NgModules and consolidate them
            </li>
            <li>Don t export the following</li>
            <ul>
              <li>private components, directives, and pipes</li>
              <li>
                Non declarable objects such as services, functions,
                configurations, and entity models
              </li>
              <li>Dynamically loaded components</li>
              <li>
                Pure service modules that don’t have public (exported)
                declarations
              </li>
            </ul>
          </ul>
          <li>imports</li>
          <ul>
            <li>
              modules whose exported classes are needed by the component
              templates declared in this module
            </li>
            <li>
              Should always import CommonModule (either directly or through
              another NgModule that re-exports it)
            </li>
            <ul>
              <li>
                Each feature module must explicitly import CommonModule to do
                any Angular work (it can import it from another module)
              </li>
            </ul>

            <li>
              Import modules with providers exactly once, preferably in the
              application's root module
            </li>
            <li>BrowserModule should be imported in the AppModule</li>
            <li>avoid circular references</li>
          </ul>
          <li>providers</li>
          <ul>
            <li>
              creators of services that this module contributes to the global
              collection of services.
            </li>
            <li>These become accessible to all parts of the app.</li>
            <li>These can also be specified at the component level</li>
          </ul>
          <li>Bootstrap</li>
          <ul>
            <li>main application view, called the root component.</li>
            <li>Only a root module should have this set.</li>
          </ul>
        </ul>
      </section>

      <h2 id="readability">Configuration & Readability</h2>
      <section>
        One way to improve readability is to:
        <ul>
          <li>
            define imports, exports, declarations, etc in a constant array
          </li>
          <li>This could even be in a separate file</li>
          <li>
            These could be split so you have one array for declaring components,
            one array declaring directives, etc
          </li>
          <li>Use the spread operator in the module definition</li>
        </ul>

        <div class="card">
          <div class="card-body">
            <code>
              @NgModule({<br />
              Declarations: &#91;<br />
              ..myComponentArray,<br />
              ..myDirectivesArray<br />
              &#93;<br />
              })
            </code>
          </div>
        </div>
      </section>

      <h2 id="context">Compilation Context</h2>
      <section>
        <li>
          Components within the same module share the same compilation context
        </li>
      </section>

      <h2 id="builtin">Common Built-In Modules</h2>
      <section>
        <ul>
          <li>BrowserModule</li>
          <ul>
            <li>use when you are running the application in a browser</li>
            <li>
              imports CommonModule and exports it, making them available to any
              module that imports BrowserModule
            </li>
            <li>
              this should be imported into the AppModule since it contains
              services that are essential to launch and run a browser app
            </li>
            <li>Should not be in a feature module</li>
          </ul>
          <li>CommonModule</li>
          <ul>
            <li>contains common directives such as NgIf, NgFor</li>
            <li>
              Need to import this in feature modules since they should not
              contain BrowserModle
            </li>
          </ul>
          <li>FormsModule</li>
          <ul>
            <li>when you want to use template driven forms</li>
          </ul>
          <li>ReactiveFormsModule</li>
          <ul>
            <li>when you want to build reactivew forms</li>
          </ul>
          <li>RouterModule</li>
          <ul>
            <li>when you want to use RouterLink, forRoot, and forChild</li>
          </ul>
          <li>HttpClientModule</li>
          <ul>
            <li>when you want to talk to a server</li>
          </ul>
        </ul>
      </section>

      <h2 id="categories">Categories</h2>
      <section>
        Feature modules fall into five categories
        <ul>
          <li>
            Domain
            <ul>
              <li>dedicated to a particular application domain</li>
              <li>
                have a top-level component with several private supporting
                subcomponents under it
              </li>
              <li>Only top-level component should be exported</li>
              <li>
                Usually don't have providers – lifecycle should be the same as
                the module lifecycle if it does
              </li>
              <li>
                Typically imported exactly once by a larger feature module
              </li>
            </ul>
          </li>
          <li>
            Routed
            <ul>
              <li>
                Domain feature modules whose top components are targets of
                router navigation routes
              </li>
              <li>
                Are lazy loaded modules are routed feature modules by definition
              </li>
              <li>
                Should not imported by any module (which would trigger eager
                loading)
              </li>
              <li>
                Don't export anything since their components never appear in the
                template of an external component
              </li>
              <li>
                Rarely have providers – if so, it should have the same lifecycle
                of the module
              </li>
            </ul>
          </li>
          <li>
            Routing
            <ul>
              <li>
                Provides routing configuration for another modules and separates
                routing concerns
              </li>
              <li>Defines routes</li>
              <li>Adds router configuration to the module's imports</li>
              <li>
                Adds guard and resolves service providers to the module's
                providers
              </li>
              <li>
                AppRoutingModule will contain the forRoot call, all other
                routing modules will use forChild
              </li>
              <li>Does not contain its own declarations</li>
              <li>Only imported by its companion module</li>
              <li>
                The name should parallel the name of its companion module using
                the suffix “Routing”
              </li>
            </ul>
          </li>

          <li>
            Service
            <ul>
              <li>Consist entirely of providers with no declarations</li>
              <li>
                The root AppModule is the only module that should import service
                modules
              </li>
            </ul>
          </li>

          <li>
            Widget
            <ul>
              <li>
                Components, directives, and popes available to external modules
              </li>
              <li>Consist entirely of declarations, most of them exported</li>
              <li>Should rarely have providers</li>
              <li>
                These are imported into any module whose component templates
                need the widgets
              </li>
            </ul>
          </li>
        </ul>
      </section>

      <h2 id="entry">Entry Components</h2>
      <section>
        <ul>
          <li>Example is AppComponent</li>

          <li>
            Component that loads imperatively (not referenced in a template)
          </li>
          <li>Opposed to component loaded declaratively via its selector</li>
          <ul>
            <li>
              locates the component using the component's selector, creates a
              HTML representation for the component, and inserts it into the DOM
              at the selected element
            </li>
          </ul>

          <li>
            Its selector does turn up in index.html, but that isn't a component
            template and the AppComponent selector does not match an element in
            any component template
          </li>

          <li>
            Components in route definitions are also entry components
            <ul>
              <li>Route definition refers to a component by its type</li>
              <li>The selector is ignored during this process</li>
            </ul>
          </li>

          <li>
            Loaded by
            <ul>
              <li>included in a routing definition</li>
              <li>
                specified in an NgModule as a bootstrapped root component
                <ul>
                  <li>usually by AppComponent in AppModule</li>
                  <li>
                    this can also be done by the modules ngDoBootsrap method
                  </li>
                </ul>
              </li>
            </ul>
          </li>

          <li>
            EntryComponents array of NgModule decorators
            <ul>
              <li>
                Components added here (either explicitly or automatically) are
                used by the Angular compiler to generate code during tree
                shaking
              </li>
              <li>
                Code imported, but not listed in EntryComponents will not be
                included
              </li>
              <li>
                Don't usually have to add anything to this since Angular ads
                components listed in NgModule.bootstrap and those in route
                definitions to entry components automatically
              </li>
              <li>Add components here that are loaded dynamically</li>
            </ul>
          </li>

          <li>Bootstrap Component</li>
          <ul>
            <li>
              this is a type of entry component that Angular loads into the DOM
              during the bootstrap process
            </li>
            <li>
              NgModule.bootstrap property tells the compiler that this is an
              entry component and it should generate code to bootstrap the
              application with this component
            </li>
            <li>
              Usually don't need to add components to entryComponents property
              since Angular adds components in the bootstrap component and those
              referenced in router configuration are added to entry components
              section automatically
              <ul>
                <li>
                  usually only need to add when you are dynamically loading
                  components by type since they will not be included in tree
                  shaking otherwise
                </li>
              </ul>
            </li>
          </ul>
        </ul>
      </section>

      <h2 id="feature">Feature</h2>
      <section>
        <ul>
          <li>
            Organization best practice, not a concept of the core Angular API
          </li>
          <li>
            Helps partition the app into focused areas
            <ul>
              <li>these are opposed to root modules</li>
            </ul>
          </li>
          <li>
            To create
            <ul>
              <li><kbd>generate module CustomerDashboard</kbd></li>
              <li>
                this will put the module in a folder named customer-dashboard
              </li>
            </ul>
          </li>
          <li>
            To add a component to this module
            <ul>
              <li>
                <kbd
                  >ng generate component
                  customer-dashboard/CustomerDashboard</kbd
                >
              </li>
              <li>This will also add the component to the module</li>
            </ul>
          </li>
        </ul>
      </section>

      <h2 id="appvsfeature">App vs Feature</h2>
      <section>
        <ul>
          <li>App modules will import BrowserModule; feature modules do not</li>
          <li>
            To define routes
            <ul>
              <li>App modules call <kbd>RouterModule.forRoot()</kbd></li>
              <li>Feature modules call <kbd>RouterModule.forChild()</kbd></li>
            </ul>
          </li>
        </ul>
      </section>

      <h3 id="shared">Shared</h3>
      <section>
        <ul>
          <li>
            SharedModule is a convention name for an NgModule with the
            components, directives, and pipes that you use everywhere in your
            app
          </li>
          <li>
            Should consist entirely of declarations, most of them exported
          </li>
          <li>
            Can also re-export modules that you use widely, such as
            CommonModule, FormsModule, etc
          </li>
          <li>Should not have providers</li>
        </ul>
      </section>

      <h3 id="lazy">Lazy Loading Feature Modules</h3>
      <section>
        <ul>
          <li>
            When loading large applications, it may make sense not to load
            everything upfront. An example would be loading the administration
            panel of an application separate from the user facing UI
          </li>
          <li>
            Lazy loading is when you load modules only when you need them. This
            is opposed to eager loading, which loads everything at once
          </li>
          <li>
            Services specific to the module to the lazy loaded should be listed
            in the providers array of that module
            <ul>
              <li>
                When the module is lazy loaded, it creates a new injector that
                is a child of the root application injector
              </li>
              <li>
                Providers are added to this child injector so they are preferred
                to the application root injector
              </li>
            </ul>
          </li>
          <li>
            Don't lazy load default routes
            <ul>
              <li>
                When the user loads the default route, lazy loading will require
                downloading the module file and all dependencies. Later the file
                needs to be parsed by the JavaScript VM and evaluated
              </li>
              <li>
                Triggering extra HTTP requests and performing unnecessary
                computations during the initial page load is a bad practice
                since it slows down the initial page rendering
              </li>
            </ul>
          </li>
        </ul>
        <p>Setup</p>
        <div>
          Configre routes to the feature modules in AppRoutingModule. For
          instance, if you are adding a User feature module, you could add the
          following to your app module routes.
        </div>
        <div class="card">
          <div class="card-body">
            <code>
              {<br />
              path: ‘user’, <br />
              loadChildren: () =&gt; import(‘./user/user.module’).then(m =&gt;
              m.UserModule) <br />
              }
            </code>
          </div>
        </div>
        <div>
          This will return a promise that contains the module to be imported.
          Use the then statement to get to the module class
        </div>
        <div>
          For feature modules:
          <ul>
            <li>Each feature acts as a doorway via the router</li>
            <li>Connects the AppRoutingModule to the feature module</li>
            <li>
              Modules hook into the following components
              <ul>
                <li>
                  Routing Modules
                  <ul>
                    <li>
                      these will use the component syntax on routes since they
                      should be eagerly loaded
                    </li>
                    <li>
                      don’t need to include the context since this will be
                      accounted for in the AppRoutingModule (default route can
                      just be an empty string)
                    </li>
                  </ul>
                </li>
                <li>Component</li>
              </ul>
            </li>
          </ul>
        </div>
      </section>
    </div>
    <script src="./assets/bootstrap/js/bootstrap.bundle.js"></script>
  </body>
</html>
