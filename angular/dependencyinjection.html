<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Index</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
    <link rel="stylesheet" href="../assets/bootstrap/css/bootstrap.min.css" />
    <link rel="stylesheet" href="./assets/styles/site.css" />
  </head>
  <body>
    <nav class="navbar navbar-expand-lg bg-light">
      <div class="container-fluid">
        <a class="navbar-brand" href="../">Home</a>
      </div>
    </nav>
    <div class="container">
      <nav class="breadcrumb">
        <ol class="breadcrumb">
          <li class="breadcrumb-item"><a href="../index.html">Home</a></li>
          <li class="breadcrumb-item">
            <a href="index.html">Angular</a>
          </li>
          <li class="breadcrumb-item active" aria-current="page">
            Dependency Injection
          </li>
        </ol>
      </nav>
      <h1>Dependency Injection</h1>
      <section class="navlinks">
        <ul>
          <li><a href="angularcli.html#basics">Basics</a></li>
          <li><a href="angularcli.html#injectors">Injectors</a></li>
          <li><a href="angularcli.html#providers">Providers</a></li>
          <li>
            <a href="angularcli.html#tokens">Injector Tokens</a>
          </li>
          <li>
            <a href="angularcli.html#optimization">Optimization</a>
          </li>
          <li>
            <a href="angularcli.html#injectionToken"
              >Injection Token Class</a
            >
          </li>
          <li>
            <a href="angularcli.html#dom">Component DOM Element</a>
          </li>
          <li>
            <a href="angularcli.html#factoryProviders"
              >Factory Providers</a
            >
          </li>
          <li>
            <a href="angularcli.html#singleton">Singleton Services</a>
          </li>
          <li>
            <a href="angularcli.html#forRoot"
              >ForRoot / ForChild Pattern</a
            >
          </li>
        </ul>
      </section>

      <h2 id="basics">Basics</h2>
      <section>
        <ul>
          <li>
            Coding pattern in which a class asks for dependencies from external
            sources rather than creating them itself
          </li>
          <li>
            In Angular, dependencies are provided when a class is created
            <ul>
              <li>
                Consumer classes don’t need to know how to create services, but
                notify Angular that it will need them
              </li>
              <li>
                Services can be injected into components, giving them access to
                that class
              </li>
            </ul>
          </li>
          <li>
            You tell Angular to inject a dependency in a component’s constructor
            by specifying a constructor parameter with the dependency type
            <ul>
              <li>
                This is technically a token, which Angular uses to pass to the
                inject and assign the result the parameter
              </li>
              <li>
                Classes must be marked with the @Injectable decorator tag to be
                injected
              </li>
            </ul>
          </li>

          <li>
            Injector is the main mechanism for supplying dependencies to
            components
            <ul>
              <li>
                When all requestee services have been resolved and returned,
                Angular can call the components constructor with those services
                as arguments
              </li>
            </ul>
          </li>
          <li>
            Components and directives have their own injectors
            <ul>
              <li>
                Services injected via the providers attribute will be available
                to that directive/component and its children
              </li>
            </ul>
          </li>
          <li>A provider in a recipe for creating a service</li>
        </ul>
      </section>

      <h2 id="injectors">Injectors</h2>
      <section>
        <ul>
          <li>
            Angular cannot inject a class anywhere until you configure an
            Angular dependency injector with a provider of that service
            <ul>
              <li>
                The injector is responsible for creating service instances and
                injecting them into classes
              </li>
              <li>
                Angular creates injectors for you as it executes the app,
                staring with the root injector that it creates during the
                bootstrap process
                <ul>
                  <li>
                    This is an application wide injector, so you don’t
                    necessarily need to create more than this
                  </li>
                </ul>
              </li>
              <li>
                An injector maintains a container of service instances that it
                has created
                <ul>
                  <li>
                    When a requested service does not exist in the container,
                    the injector makes one using the registered provider and
                    adds it to the injector before returning the service to
                    Angular
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            Injectors are inherited, which mean if a given injector cannot
            resolve a dependency, it asks the parent injector to resolve it
            (hierarchical injection system)
            <ul>
              <li>
                A component can get services from its own injector, from the
                injectors of its component ancestors, from the injector of its
                parent NgModule, or from the root injector (injector bubbling)
                <ul>
                  <li>
                    Use @Host to prevent this bubbling behavior; for instance,
                    if a component is used multiple times and each should have
                    its own version of a service
                  </li>
                </ul>
              </li>
              <li>
                Constructor(@Host myServ: MyService)
                <ul>
                  <li>
                    Use @Self in a component to only look within the component
                    injector
                  </li>
                  <li>
                    Use @SkipSelf to look in any ancestor component injectors
                    for a dependency
                  </li>
                </ul>
              </li>

              <li>
                Services are singletons within the scope of an injector, so
                there is only one instance of a service in a given injector
              </li>
              <li>
                Nested injectors can create their own service instances
                <ul>
                  <li>
                    A child injector is created when a component is created that
                    has a providers metadata item specified
                  </li>
                  <li>
                    A child injector is also created when a new NgModule is lazy
                    loaded at run time
                  </li>
                  <li>
                    When NgModules or components are destroyed, Angular also
                    destroys that injector and that injector’s service instances
                  </li>
                </ul>
              </li>
            </ul>
          </li>

          <li>
            Injectors can be configured with providers at different levels of
            your app, by setting a metadata value in one of three places
            <ul>
              <li>
                The @Injectable() decorator for the service itself
                <div class="card">
                  <div class="card-body">
                    <code> .. { providedIn: &quot;root&quot; } .. </code>
                  </div>
                </div>
                <ul>
                  <li>
                    Uses the providedIn metadata option where you can specify
                    the provider of a decorated service class with the root
                    injector, or with the injector for a specific NgModule
                  </li>
                  <li>Angular CLI will set this up by default</li>
                  <li>
                    This allows Angular to optimize an app by removing the
                    service form the compiled application if it isn’t used (tree
                    shaking)
                  </li>
                </ul>
              </li>
              <li>
                The @NgModule() decorator for an NgModule
                <ul>
                  <li>
                    Uses the providers metadata option where you can configure
                    providers for NgModule level or component level injectors
                  </li>
                  <li>Makes it available to all components in the NgModule</li>
                  <li>
                    The single instance is used for all components in the module
                  </li>
                  <li>Using this will mean it is not tree shakable</li>
                </ul>
              </li>
              <li>
                The @Component() decorator for a component
                <ul>
                  <li>
                    Uses the providers property of the @Component metadata
                  </li>
                  <li>
                    Registering at the component level means you get a new
                    instance of the service with each new instance of that
                    component
                  </li>
                  <li>.. providers; [ HeroService ] ..</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            Root injector
            <ul>
              <li>This is the only root injector for the application</li>
              <li>Used when registering at the root or AppModule level</li>
              <li>
                Every class that uses a service registered here will the same
                instances unless you configure another provider with a child
                injector
              </li>
            </ul>
          </li>
        </ul>
      </section>

      <h2 id="providers">Providers</h2>
      <section>
        <ul>
          <li>
            A provider tells an injector how to obtain or create a dependency
            <ul>
              <li>
                You must configure an injector with a provider before that
                injector can create a service
              </li>
              <li>
                This can be the service class itself, so that the injector can
                use new to create an instance
                <ul>
                  <li>
                    This class should have the @Injectable metadata decorator
                  </li>
                  <li>
                    This class must be registered with an injector, which is the
                    object that is responsible for choosing and injecting the
                    provider where it is required
                  </li>
                </ul>
              </li>

              <li>
                Angular CLI will by default register the provider with the root
                injector
              </li>
            </ul>
          </li>
          <li>
            A dependency provider configures an injector with a DI Tokens, which
            that injector uses to provide a concrete, runtime version of a
            dependency value
            <ul>
              <li>
                When you configure an injector with a provider, you associate
                that provider with a DI token
              </li>
              <li>
                The injector maintains an internal token provider map that it
                references when asked for a dependency
              </li>
              <li>
                Usually, the dependency value is an instance and the class type
                serves as its own lookup key
                <ul>
                  <li>
                    Default behavior is of the injector to instantiate the class
                    with new
                  </li>
                  <li>
                    It doesn't have to be a service, it could be a function or a
                    value
                  </li>
                </ul>
              </li>
            </ul>
          </li>

          <li>
            Registering a class as a provider
            <ul>
              <li>
                The longhand version of registering a class as a provider is:
                <div class="card">
                  <div class="card-body">
                    <code>{ provide: MyClass, useClass: MyClass }</code>
                  </div>
                </div>
              </li>
              <li>
                The shorthand version is just the class name
                <ul>
                  <li>MyClass</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            To supply a different class than the provide name, use a provider
            object literal
            <ul>
              <li>
                Provide – holds the token that serves as the key for both
                locating a dependency value and configuring the injector
              </li>
              <li>
                useClass – use this when you want to provide a different class
                when one is asked for
              </li>
              <li>
                This will provide an instance of BetterLogger when Logger is
                requested
                <div class="card">
                  <div class="card-body">
                    <code>
                      &#91;{ provide: Logger, useClass: BetterLogger }&#93;
                    </code>
                  </div>
                </div>
              </li>
            </ul>
          </li>

          <li>
            To provide the object held in variable silentLogger whenever Logger
            is requested
            <div class="card">
              <div class="card-body">
                <code>
                  &#91;{ provide: Logger, useValue: silentLogger }&#93;
                </code>
              </div>
            </div>
            <ul>
              <li>You can use this to pass in a function via injection</li>
            </ul>
          </li>
          <li>
            To supply an object you have already created
            <ul>
              <li>
                Provide – holds the token that serves as the key for both
                locating a dependency value and configuring the injector
              </li>
              <li>
                useExisting - use to alias one class name for another
                <div class="card">
                  <div class="card-body">
                    <code>
                      &#91;{ provide: OldLogger, useExisting: NewLogger }&#93;
                    </code>
                  </div>
                </div>
                <ul>
                  <li>
                    This will create an instance and provide a NewLogger
                    instance whenever OldLogger is requested
                    <ul>
                      <li>
                        OldLogger is a class, but it is never instantiated
                      </li>
                    </ul>
                  </li>
                  <li>Probably will never need this</li>
                  <li>Also known as the alias provider</li>
                  <li>
                    Situations where you would want to use this to minimize an
                    API
                    <ul>
                      <li>
                        They would get the full class, but Intellisense would
                        only be able to see the methods defined on OldLogger
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            UseFactory
            <div class="card">
              <div class="card-body">
                <code>{ provide: Logger, useFactory: factory() }</code>
              </div>
            </div>
            <ul>
              <li>Uncommon to use</li>
              <li>
                Registers a class Logger, but the second parameter is a function
                that you can pass parameters to
              </li>
              <li>Only used in complex cases – see Angular docs</li>
            </ul>
          </li>
        </ul>
      </section>

      <h2 id="tokens">Injector Tokens</h2>
      <section>
        <ul>
          <li>
            To get a service from a dependency injector, you must give it a
            token:
            <ul>
              <li>
                This is usually done by specifying a constructor parameter and
                its type
              </li>
              <li>The parameter type serves as the injector lookup token</li>
              <li>
                Angular passes this token to the injector, which examines its
                register for the type of the parameter
              </li>
              <li>
                If found, it assigns the match to the parameter
                <ul>
                  <li>
                    When looking up a service, the injector will use a cached
                    version if it has been requested before
                  </li>
                  <li>Otherwise, it creates a new instance</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            DI is easiest when a provider token is a class that is also the type
            of returned dependency object, or service – this doesn’t have to be
            true though
            <ul>
              <li>
                Doesn’t have to be a class or can be an entirely different class
              </li>
            </ul>
          </li>
          <li>
            TypeScript has a shorthand that can be used
            <div class="card">
              <div class="card-body">
                <code> Constructor(private myService: MyService) { …" </code>
              </div>
            </div>
            <ul>
              <li>Creates a private variable in the class</li>
              <li>Assigns myService to that private variable</li>
              <li>
                The myService service will be injected into the component by
                Angular
              </li>
            </ul>
          </li>
          <li>See documentation for details on creating a custom provider</li>
          <li>
            Useful for something like testing a component that requires
            localstorage
          </li>
        </ul>
      </section>

      <h2 id="optimization">Optimization</h2>
      <section>
        <ul>
          <li>
            Specifying providers in the @Injectable decorator of the service
            itself allows optimizers to perform tree shaking and remove services
            that are not necessary to the application, leading to smaller bundle
            sizes
          </li>
          <li>
            Specifying the root injector is a good choice as the same instance
            can be used everywhere in the application
          </li>
          <li>Use NgModule providers option if a module is lazy loaded</li>
          <li>
            Use component level injectors if you want to restrict the lifetime
            of the service to the lifetime of the component
          </li>
          <li>
            Use component level injectors if need each component instance needs
            to have its own instance of a service that is separate from others
          </li>
          <li>
            You can use the hierarchy of injectors to provide a more specialized
            implementation of a service deeper in the component tree
          </li>
          <li>
            You can specify an optional dependency as follows in the
            constructor:
            <div class="card">
              <div class="card-body">
                <code>@Optional() private logger: Logger</code>
              </div>
            </div>
          </li>
          <li>
            You must be prepared for a null value in this if it does not have a
            registered provider anywhere
          </li>
        </ul>
      </section>

      <h2 id="injectionToken">Injection Token Class</h2>
      <section>
        <ul>
          <li>
            Allows you to create a token that you can register with and Injector
            to provide an object to a component via dependency injection
          </li>
          <li>
            The InjectionToken allows you to do this without having to wrap the
            target object in a service
            <ul>
              <li>One solution to handling 3rd party libraries</li>
              <li>
                It is bad practice to reference 3rd party libraries (or
                anything) that exist in the global namespace
              </li>
            </ul>
          </li>
          <li>
            An example of this would be using Toastr
            <ul>
              <li>
                Instead of wrapping a custom service class around the global
                Toastr object, you can create an injection token so the Toastr
                object is injected into components
              </li>
            </ul>
          </li>
          <li>
            First create a token that you can use in dependency injection
            without creating a class. In a file (toastr..service.ts)...
            <ul>
              <li>Import InjectionToken from @angular/core</li>
              <li>
                Create an instance of the InjectionToken
                <div class="card">
                  <div class="card-body">
                    <code>
                      export let TOASTR_TOKEN = new
                      InjectionToken&lt;Toastr&gt;(&quot;toastr&quot;)
                    </code>
                  </div>
                </div>
                <ul>
                  <li>Convention is to name in all caps</li>
                  <li>TOASTR_TOKEN is a JavaScript object</li>
                  <li>
                    String in the parameter is a description used in debugging
                  </li>
                </ul>
              </li>
              <li>
                Define a Toastr interface within this file and provide the
                methods that should be available on it. This is just for type
                safety
              </li>
            </ul>
          </li>
          <li>
            In module
            <ul>
              <li>
                Import the InjectionToken
                <div class="card">
                  <div class="card-body">
                    <code>
                      import {TOASTR_TOKEN } from &quot;toaster.service&quot;
                    </code>
                  </div>
                </div>
              </li>
              <li>
                Declare the global object for toastr in the module
                <div class="card">
                  <div class="card-body">
                    <code>
                      let toastr: Toastr = window&#91;&quot;toastr&quot;&#93;
                    </code>
                  </div>
                </div>
                <ul>
                  <li>
                    This tells TypeScript that there will be a toastr object in
                    the global namespace that it is not aware of
                  </li>
                  <li>
                    It will be of type Toastr, the interface defined previously
                  </li>
                </ul>
              </li>
              <li>
                Register the injection token in the providers section of the
                module
                <div class="card">
                  <div class="card-body">
                    <code>{ provide: TOASTR_TOKEN, useValue: toastr }</code>
                  </div>
                </div>
                <ul>
                  <li>
                    This tells registration that whenever anyone requests a
                    dependency using the TOASTR_TOKEN token, give them the
                    toastr object from the global space
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            In the component you want to use it in, add the following as a
            parameter to the constructor
            <div class="card">
              <div class="card-body">
                <code>@Inject(TOASTR_TOKEN) private toastr: Toaster</code>
              </div>
            </div>
            <ul>
              <li>Need to import Inject from @angular/core</li>
            </ul>
          </li>
        </ul>
      </section>

      <h2 id="dom">Component DOM Element</h2>
      <section>
        <ul>
          <li>
            Although it is generally not encouraged, you can inject the
            component DOM element into a component class
            <ul>
              <li>
                Useful if you are using something like jQuery which needs DOM
                access
              </li>
            </ul>
          </li>
          <li>
            Inject ElementRef into the constructor or the component
            <ul>
              <li>
                The nativeElement property is what you want to reference to get
                to the DOM element
              </li>
            </ul>
          </li>
        </ul>
      </section>

      <h2 id="factoryProviders">Factory Providers</h2>
      <section>
        <ul>
          <li>
            Use when you need to create a dependency dynamically on information
            you may not have until runtime
          </li>
        </ul>
      </section>

      <h2 id="singleton">Singleton Services</h2>
      <section>
        <ul>
          <li>
            A service for which only one instance exists in an application
          </li>
          <li>
            There are two ways to make a service a singletons
            <ul>
              <li>
                Set the providedIn property of the @Injectable decorator to
                "root"
                <ul>
                  <li>Preferred way</li>
                  <li>Makes services tree shakable</li>
                </ul>
              </li>
              <li>
                Include the service in the AppModule or in a module that is only
                imported by the AppModule
              </li>
            </ul>
          </li>
        </ul>
      </section>

      <h3 id="forRoot">ForRoot / ForChild Pattern</h3>
      <section>
        <ul>
          <li>
            If a module is loaded in multiple feature modules, that leads to
            duplication of service registration
            <ul>
              <li>
                Services will have multiple instances and no longer behave as a
                singleton
              </li>
            </ul>
          </li>
          <li>
            There are several ways to prevent this
            <ul>
              <li>
                Use the providedIn syntax on the Injectable decorator instead of
                registering the service in the module
              </li>
              <li>Separate services into their own module</li>
              <li>Define forRoot and forChild methods in the module</li>
            </ul>
          </li>
          <li>
            The ForRoot / ForChild method pattern is a static method convention
            that makes it easy for developers to configure services and
            providers that are intended to the singletons
            <ul>
              <li>Example is RouterModule.forRoot() used in routing</li>
              <li>
                This is how the router module prevents multiple instances of a
                Router service (which would break the application since multiple
                routers would break the application)
              </li>
              <li>The root application must import RouterModule</li>
              <li>
                Each feature module must import RouterModule so their components
                can place router directives into their templates
              </li>
              <li>
                The forRoot method creates a new Router instance; forChild does
                not create a new Router instance
              </li>
            </ul>
          </li>
          <li>
            To do this
            <ul>
              <li>
                Create a static method forRoot() on the module
                <ul>
                  <li>This takes a UserServiceConfig object</li>
                  <li>
                    Returns a ModuleWithProviders object
                    <ul>
                      <li>
                        Plain object with properties of ngModule and providers
                      </li>
                      <li>Put all providers in the providers array</li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>Place the providers into the forRoot method</li>
            </ul>
          </li>
          <li>
            See documentation for more info:
            https://angular.io/guide/singleton-services#the-forroot-pattern
          </li>
        </ul>
      </section>
    </div>
    <script src="../assets/bootstrap/js/bootstrap.bundle.js"></script>
  </body>
</html>
