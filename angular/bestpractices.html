<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Index</title>
    <base href="/" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
    <link rel="stylesheet" href="./assets/bootstrap/css/bootstrap.min.css" />
    <link rel="stylesheet" href="./assets/styles/site.css" />
  </head>
  <body>
    <nav class="navbar navbar-expand-lg bg-light">
      <div class="container-fluid">
        <a class="navbar-brand" href="./">Home</a>
      </div>
    </nav>
    <div class="container">
      <nav class="breadcrumb">
        <ol class="breadcrumb">
          <li class="breadcrumb-item"><a href="../index.html">Home</a></li>
          <li class="breadcrumb-item">
            <a href="./angular/index.html">Angular</a>
          </li>
          <li class="breadcrumb-item active" aria-current="page">
            Best Practices and Style Guide Recommendations
          </li>
        </ol>
      </nav>
      <h1>Best Practices and Style Guide Recommendations</h1>
      <section class="navlinks">
        <ul>
          <li>
            <a href="./angular/bestpractices.html#functionCalls"
              >Avoid Function Calls in Templates</a
            >
          </li>
          <li><a href="./angular/bestpractices.html#pipes">Pipes</a></li>
          <li>
            <a href="./angular/bestpractices.html#providerRegistration"
              >Provider Registration</a
            >
          </li>
          <li>
            <a href="./angular/bestpractices.html#onPush"
              >OnPush Change Detection Strategy</a
            >
          </li>
          <li>
            <a href="./angular/bestpractices.html#assorted"
              >Assorted Best Practices</a
            >
          </li>
          <li>
            <a href="./angular/bestpractices.html#performance"
              >Performance Improvement</a
            >
          </li>
          <li>
            <a href="./angular/bestpractices.html#styleGuide"
              >Style Guide Recommendations</a
            >
          </li>
        </ul>
      </section>

      <h2 id="functionCalls">Avoid Function Calls in Templates</h2>
      <section>
        <ul>
          <li>
            Function calls within templates are convenient and technically
            valid, but they can lead to performance problems
          </li>
          <li>
            The function will be executed each time an Angular change detection
            cycle runs
          </li>
          <ul>
            <li>
              Angular must execute the function on each change detection cycle
              to determine whether the value returned has changed
            </li>
            <li>
              Angular cannot predict if the return value has changed, so the
              function must be executed on each change detection cycle
            </li>
            <li>This is done even if the value never changes</li>
            <li>Getters are also vulnerable to this</li>
          </ul>
          <li>
            Setting the change detection strategy to OnPush doesn’t help this
          </li>
          <li>
            Alternatives
            <ul>
              <li>
                Use ngOnInit and call the function once to assign the computed
                value to a property
              </li>
              <li>
                Use ngOnChanges to call the function each time an input value
                changes and assing the computed value to a property
              </li>
              <li>
                Use pure pipes
                <ul>
                  <li>
                    Angular knows that a pure pipe’s return value does not
                    change if the pipe’s input does not change
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </section>

      <h2 id="pipes">Pipes</h2>
      <section>
        <ul>
          <li>Favor pure pipes</li>
          <li>
            Use built in and custom pipes in templates to transform data instead
            of component method calls
            <ul>
              <li>Function calls are evaluated with every change detection</li>
              <li>Pipes are only called when the input value changes</li>
            </ul>
          </li>
          <li>
            There are two types of pipes
            <ul>
              <li>
                pure
                <ul>
                  <li>
                    Produce the same output when invoked with the same set of
                    arguments
                  </li>
                  <li>Examples include DecimalPipe and DatePipe</li>
                  <li>
                    Angular will only evaluate a given pure pipe call only if it
                    has received different arguments compared to its previous
                    invocation
                  </li>
                  <li>
                    All pipes in Angular are pure by default; you can add a
                    pure: true attribute to the @Pipe declaration, but this is
                    redundant
                  </li>
                </ul>
              </li>
              <li>
                impure
                <ul>
                  <li>
                    Can hold state and can produce different output for the same
                    set of arguments
                  </li>
                  <li>Example is AsyncPipe</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            You can use a pure pipe instead of a expression in the template to
            boost performance; added benefit of caching since it will not
            evaluate the function if the inputs are not different
          </li>
          <li>
            If there are multiple pipe expressions that are the same in
            different places in the component tree, they will be evaluated
            independently
            <ul>
              <li>
                It doesn't cache in this for all instances of the pipe. It just
                caches for each instance of the pipe independently.
              </li>
              <li>
                You can use memoization in this case to get a slight boost if
                there are values that are repeated in the different pipes
              </li>
              <li>
                Memoization only works when dealing with primitives
                <ul>
                  <li>
                    Often two instances of data structures which have different
                    references can hold the same data, but this is not
                    guaranteed
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </section>

      <h2 id="providerRegistration">Provider Registration</h2>
      <section>
        <ul>
          <li>Consider optimizing where you are registering services</li>
          <li>
            Use ProvidedIn: ‘root’ on @Injectable where you can
            <ul>
              <li>A single instance is created for the entire application</li>
              <li>Allows tree shaking</li>
            </ul>
          </li>
          <li>
            Other levels can have undesired results
            <ul>
              <li>
                Registering at the module level will include a new version of
                the service in each module
              </li>
              <li>
                Registering at the component level will create a new version of
                the service for each component
              </li>
            </ul>
          </li>
        </ul>
      </section>

      <h2 id="onPush">OnPush Change Detection Strategy</h2>
      <section>
        <ul>
          <li>
            Do not perform heavy computations in templates
            <ul>
              <li>
                Expressions in templates are re-evaluated every time change
                detection gets triggered
              </li>
              <li>
                It does this after an event, re-evaluates all the expressions in
                the templates and compares them with their previous values. If
                there is a change, it will update the DOM
              </li>
            </ul>
          </li>
          <li>
            Use OnPush custom change detection strategy for a component when you
            are sure the values will only change when the input values change
            <ul>
              <li>
                This will use an equality check to see if the inputs changed.
                <ul>
                  <li>
                    So, if you have an array as in input and push a new item
                    from the parent component, it will not update since the
                    array is compared by reference.
                  </li>
                </ul>
              </li>
              <li>
                Will trigger a change detection cycle when we pass a new value
                to any of its inputs or when an event inside the component
                happens
                <ul>
                  <li>
                    It can also help to decompose a component when using this
                    strategy so that change events within a component do not
                    trigger unnecessary re-execution of template expressions
                  </li>
                </ul>
              </li>
              <li>
                You can force a change using arrayName.slice() to create a copy
                of the array
              </li>
            </ul>
          </li>
        </ul>
        <div class="card">
          <div class="card-body">
            <code>
              @Computer({ changeDetection:
              ChangeDetectionStrategy.OnPush })
            </code>
          </div>
        </div>
      </section>

      <h2 id="assorted">Assorted Best Practices</h2>
      <section>
        <ul>
          <li>
            Minimize writing custom components that replace or encapsulate
            single elements
            <ul>
              <li>
                Example of this would be replacing as single input element with
                a my-input component
              </li>
              <li>
                Problems that arise
                <ul>
                  <li>
                    Consumer cannot customize the attributes of the native
                    element unless the component API allows it
                    <ul>
                      <li>
                        HTML element APIs are usually quite extensive, so a
                        single element custom component limits what can be done
                        with it
                      </li>
                      <li>
                        HTML element APIs are usually quite extensive, far more
                        than can be economically replicated in a custom
                        component
                      </li>
                    </ul>
                  </li>
                  <li>
                    Native elements have built in accessibility attributes that
                    are overwritten by implementing them as a component
                  </li>
                  <li>
                    Native elements are an API that consumers can use that they
                    are already familiar with
                    <ul>
                      <li>Must relearn a different API on custom components</li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>
                Better solution is to use directives to augment existing
                elements
                <ul>
                  <li>Keeps the native elements exposed</li>
                  <li>Angular Material takes this approach</li>
                </ul>
              </li>
            </ul>
          </li>

          <li>Use ARIA attributes to describe what a component does</li>
          <li>
            Use strongly typed objects for type safety
            <ul>
              <li>Avoid <em>any</em> types since you lose type safety</li>
            </ul>
          </li>
          <li>
            The correct way of component communication is to
            <ul>
              <li>Let parent components pass data to their children</li>
              <li>
                Let children notify the parents when an action has been
                performed
              </li>
            </ul>
          </li>

          <li>
            Inputs should not be mutated within components
            <ul>
              <li>
                Mutating or redeclaring input values can lead to bugs that are
                difficult to diagnose
              </li>
              <li>
                Never mutate data in a component that comes from outside the
                component
                <ul>
                  <li>Mutating data from within the component is fine</li>
                </ul>
              </li>
              <li>
                Solutions
                <ul>
                  <li>Mark as readonly</li>
                  <li>Define the interface as ReadonlyArray</li>
                </ul>
              </li>
            </ul>
          </li>

          <li>
            Component design
            <ul>
              <li>Components should be small and focused</li>
            </ul>
          </li>
        </ul>
      </section>

      <h2 id="performance">Performance Improvement</h2>
      <section>
        <ul>
          <li>Cache data values that do not change in service classes</li>
          <li>
            <a href="https://blog.mgechev.com/2017/11/11/faster-angular-applications-onpush-change-detection-immutable-part-1/" target="_blank">https://blog.mgechev.com/2017/11/11/faster-angular-applications-onpush-change-detection-immutable-part-1/</a>            
          </li>
          <li>Use Immutable.JS</li>
          <li>            
            <a href="https://github.com/mgechev/angular-performance-checklist" target="_blank">https://github.com/mgechev/angular-performance-checklist</a>
            <ul>
              <li>
                Network optimizations
                <ul>
                  <li>
                    Remove template white spaces
                    <ul>
                      <li>
                        removing white spaces from templates reduces payload
                        sizes
                      </li>
                      <li>
                        AOT generated code will remove white spaces by default
                      </li>
                      <li>there are ways to influence this behavior</li>
                      <li>
                        https://angular.io/api/core/Component#preserving-whitespace
                      </li>
                    </ul>
                  </li>
                  <li>Ahead-of-Time Compilation</li>
                  <li>
                    Lazy loading for large applications with hundreds of
                    dependencies
                  </li>
                  <li>use an Application Shell</li>
                  <li>use Service Workers</li>
                </ul>
              </li>
              <li>
                Runtime Optimizations
                <ul>
                  <li>
                    use enableProcMode
                    <ul>
                      <li>
                        in development mode Angular performs some extra checks
                        in order to verify that performing change detection does
                        not result in any additional changes to any of the
                        bindings to ensure that unidirectional data flow is
                        followed
                      </li>
                      <li>this should be disabled for production</li>
                    </ul>
                  </li>

                  <li>AoT Compilation</li>
                  <li>
                    Use the ChangeDetectionStrategy.Onpush to restrict change
                    detentions in a component to only when inputs change or an
                    event occurs within the component
                  </li>
                  <li>Use Pure Pipes</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </section>

      <h2 id="styleGuide">Style Guide Recommendations</h2>
      <section>
        <ul>
          <li>
            One component, service, directive per file
            <ul>
              <li>Limit files to 400 lines of code</li>
            </ul>
          </li>
          <li>Keep functions small, no more than 75 lines</li>
          <li>
            File naming
            <ul>
              <li>
                Keep conventions consistent
                <ul>
                  <li>Feature.type.ts</li>
                  <li>
                    Type should be
                    <ul>
                      <li>Service</li>
                      <li>Component</li>
                      <li>Pipe</li>
                      <li>Module</li>
                      <li>Directive</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            Class names
            <ul>
              <li>Match name of class to the name of the file</li>
              <li>Append the type</li>
              <li>
                Examples
                <ul>
                  <li>
                    App.component.ts should contain the class AppComponent
                  </li>
                  <li>
                    Hero-list.component.ts should contain the class
                    HeroListComponent
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            Services
            <ul>
              <li>
                Either
                <ul>
                  <li>include Service in the name (such as HeroService)</li>
                  <li>indicate agency by ending in “-er” (such as Logger)</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            Custom directives
            <ul>
              <li>
                Should use lower camel case for naming selectors of directives
              </li>
              <li>Should use a custom prefix</li>
              <li>Don’t use the ng prefix</li>
              <li>
                Use attribute directives when you have presentation logic
                without a template
              </li>
              <li>
                Should be used when you have presentation logic without a
                template
                <ul>
                  <li>
                    An element may have more than one attribute directive
                    applied
                  </li>
                </ul>
              </li>
              <li>
                Use @HostListener and @HostBinding decorators
                <ul>
                  <li>
                    Favor over host property of @Directive and @Component
                    decorators
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            Custom pipes
            <ul>
              <li>Class name should use UpperCamelCase to name</li>
              <li>Name property should use lowerCamelCase</li>
              <li>Cannot use hyphens there</li>
            </ul>
          </li>

          <li>
            Modules
            <ul>
              <li>
                Name the module after the feature and folder it resides in
              </li>
              <li>Give filename a module.ts extension</li>
              <li>Give the module class name a suffix of Module</li>
              <li>
                Routing module
                <ul>
                  <li>Give filename a routing.module.ts suffix</li>
                  <li>Class should have a RoutingModule suffix</li>
                  <li>Example is HerosRoutingModule</li>
                </ul>
              </li>
              <li>
                App root module
                <ul>
                  <li>Need least one root NgModule</li>
                  <li>Can be in src/app</li>
                  <li>Name it app.module.ts</li>
                </ul>
              </li>
              <li>
                Feature modules
                <ul>
                  <li>Place in a folder named the same as the feature area</li>
                  <li>App/heroes/heroes.module.ts</li>
                </ul>
              </li>
              <li>
                Shared module
                <ul>
                  <li>
                    Create a shared folder with a SharedModule
                    <ul>
                      <li>App/shared/shared.module.ts</li>
                    </ul>
                  </li>
                  <li>
                    This should contain items that are used in multiple modules
                  </li>
                  <li>
                    Import modules required such as CommonModule and FormsModule
                  </li>
                  <li>Export all items that other modules need to use</li>
                  <li>
                    Consider if services should be placed here
                    <ul>
                      <li>
                        You don’t want each module to have its own separate
                        instance of singleton services
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            Components
            <ul>
              <li>
                Keep templates and styles in separate files (when over 3 lines
                long)
              </li>
              <li>
                Inputs/ Outputs
                <ul>
                  <li>
                    Use input and output decorators, not properties on the
                    component configuration object
                  </li>
                  <li>
                    If possible, keep them on the same line as the rest of the
                    declaration
                  </li>
                  <li>Avoid aliasing inputs and outputs</li>
                  <li>
                    Provide a default value for inputs or use ? to explicitly
                    mark the property as optional
                    <ul>
                      <li>Do not suppress this with !</li>
                    </ul>
                  </li>
                  <li>
                    Do not use on prefix for output events
                    <div class="card">
                      <div class="card-body">
                        <code>
                          @Output savedTheDay = new EventEmitter&lt;Boolean&gt;()
                        </code>
                      </div>
                    </div>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            Organize members as such
            <ul>
              <li>Public properties, alphabetized</li>
              <li>Private properties, alphabetized</li>
              <li>Public methods, alphabetized</li>
              <li>Private methods, alphabetized</li>
            </ul>
          </li>
          <li>
            Keep logic minimal and only focused on that required for the view
            <ul>
              <li>Delegate complex, duplicated logic to services</li>
              <li>
                Put presentation logic in the component class, not the template
              </li>
            </ul>
          </li>
          <li>
            Events and event handlers
            <ul>
              <li>
                Use on prefix for event handlers, followed by the event name
                <ul>
                  <li>onSavedTheDay</li>
                </ul>
              </li>
              <li>
                Do not use on prefix for events
                <div class="card">
                  <div class="card-body">
                    <code>
                      @Output savedTheDay = new EventEmitter&lt;Boolean&gt;()"
                    </code>
                  </div>
                </div>
              </li>
            </ul>
          </li>
          <li>
            Component selectors should be
            <ul>
              <li>Dashed-case or kebab-case (toh-hero-button)</li>
              <li>
                Include a prefix indicating the feature area or the application
                itself
              </li>
              <li>Easier to identify and prevents naming collisions</li>
            </ul>
          </li>
          <li>
            When using lifecycle hooks, implement lifecycle hook interfaces
          </li>
          <li>
            Project structure
            <ul>
              <li>
                Keep all source code in src folder
                <ul>
                  <li>Keep 3rd party libraries out of it</li>
                </ul>
              </li>
              <li>
                All feature areas should have their own folder with own NgModule
              </li>
              <li>
                Keep folder structure flat for as long as possible
                <ul>
                  <li>Consider subfolders when you hit 7 or more files</li>
                </ul>
              </li>
              <li>
                Consider crating a folder for a component when it has multiple
                accompanying files
              </li>
            </ul>
          </li>
        </ul>
      </section>
    </div>
    <script src="./assets/bootstrap/js//bootstrap.bundle.js"></script>
  </body>
</html>
