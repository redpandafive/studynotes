<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Index</title>
    <base href="/" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
    <link rel="stylesheet" href="./assets/bootstrap/css/bootstrap.min.css" />
    <link rel="stylesheet" href="./assets/styles/site.css" />
  </head>
  <body>
    <nav class="navbar navbar-expand-lg bg-light">
      <div class="container-fluid">
        <a class="navbar-brand" href="./">Home</a>
      </div>
    </nav>
    <div class="container">
      <nav class="breadcrumb">
        <ol class="breadcrumb">
          <li class="breadcrumb-item"><a href="../index.html">Home</a></li>
          <li class="breadcrumb-item">
            <a href="./angular/index.html">Angular</a>
          </li>
          <li class="breadcrumb-item active" aria-current="page">Decorators</li>
        </ol>
      </nav>
      <h1>Decorators</h1>
      <section class="navlinks">
        <ul>
          <li><a href="./angular/angularcli.html#attribute">Attribute</a></li>
          <li>
            <a href="./angular/angularcli.html#hostListener">HostListener</a>
          </li>
          <li>
            <a href="./angular/angularcli.html#hostBinding">HostBinding</a>
          </li>
          <li><a href="./angular/angularcli.html#viewChild">ViewChild</a></li>
        </ul>
      </section>

      <h2 id="attribute">Attribute</h2>
      <section>
        <ul>
          <li>
            Use when passing a static string value to a child component
            <ul>
              <li>
                Unlike a static value bound via @Input, this is not re-evaluated
                on each change cycle
              </li>
              <li>
                Use when a value passed is a fixed value that never changes
              </li>
              <li>Angular will evaluate it once, then forget about it</li>
            </ul>
          </li>
          <li>
            Can give a performance boost since it is not re-revaluated on each
            change cycle as Inputs are
            <ul>
              <li>
                This is not data binding, so make sure you don’t try any data
                binding syntax
              </li>
            </ul>
          </li>
          <li>
            <a
              href="https://wldomiciano.com/en/how-to-use-attribute-decorator-in-angular/"
              >https://wldomiciano.com/en/how-to-use-attribute-decorator-in-angular</a
            >
          </li>
        </ul>
        <p>
          Define this in the parent template with an attribute of type on the
          component
        </p>
        <div class="card">
          <div class="card-body">
            <code>
              Constructor(@Attribute('type') public type: string = 'primary') {
              }
            </code>
          </div>
        </div>
        <p>
          The attribute will not have any data binding, so no square brackets,
          interpolation, etc.
        </p>
        <div class="card">
          <div class="card-body">
            <code>
              &lt;app-hello type=&quot;secondary&quot;&gt;&lt;/app-hello&gt;
            </code>
          </div>
        </div>
      </section>

      <h2 id="hostListener">HostListener</h2>
      <section>
        <ul>
          <li>
            Declares a host listener
            <ul>
              <li>
                Allows you to handle events of the host element in a custom
                directive class
              </li>
              <li>
                Angular will invoke the decorated method when the host element
                emits the specified event
              </li>
              <li>
                Use on a custom directive to listen for events in the element
                where the directive is applied
              </li>
            </ul>
          </li>
          <li>
            Essentially performs the same function as (click)=”myClickHandler()”
            in a template
          </li>
        </ul>
        <p>
          Example: Fire when the mouse over event occurs in the host element
        </p>
        <div class="card">
          <div class="card-body">
            <code>
              @HostListener('mouseover') onMouseOver() {&#10;
              this.renderer.setElementStyle(this.el.nativeElement, 'color',
              color);&#10;}
            </code>
          </div>
        </div>
      </section>

      <h2 id="hostBinding">HostBinding</h2>
      <section>
        <ul>
          <li>
            Declares a host property binding
            <ul>
              <li>
                Allows you to se the properties of the host element from the
                directive class
              </li>
            </ul>
          </li>
          <li>Similar to [value]=”myValue” in a template</li>
          <li>
            This is the template version:
            <a
              href="https://dzone.com/articles/what-are-hostbinding-and-hostlistener-in-angular"
              >https://dzone.com/articles/what-are-hostbinding-and-hostlistener-in-angular</a
            >
          </li>
        </ul>
        <p>To set the border of the host element</p>
        <div class="card">
          <div class="card-body">
            <code>@HostBinding(&quot;style.border&quot;) border: string;</code>
          </div>
        </div>
        <p>To modify</p>
        <div class="card">
          <div class="card-body">
            <code> code=&quot;this.border='5px solid green'&quot;</code>
          </div>
        </div>
      </section>

      <h2 id="viewChild">ViewChild</h2>
      <section>
        <ul>
          <li>
            Allows you to get a reference to an element on a component’s
            template and inject it into the component
          </li>
          <li>
            This can be used to access
            <ul>
              <li>A child component (including its public methods)</li>
              <li>A HTML element on the component template</li>
              <li>A directive in the template</li>
            </ul>
          </li>
          <li>
            Useful when you
            <ul>
              <li>
                Need to access a child component but using template variables is
                too limited
              </li>
              <li>Need to call public methods on a child component</li>
            </ul>
          </li>
          <li>
            Must wait for AfterViewInit event to access this data
            <ul>
              <li>Reference may not be available on OnInit event</li>
              <li>See static property for exception to this</li>
            </ul>
          </li>
          <li>
            There is an optional static property that changes lifecycle
            availability
            <ul>
              <li>
                The default value of this is false
                <ul>
                  <li>
                    This tells Angular that the ViewChild will be available at a
                    later time
                  </li>
                  <li>
                    Indicates it is dependent on some condition (such as a
                    simple component property binding)
                  </li>
                  <li>
                    Can lead to a higher performance load since we must always
                    be checking if the ChildComponent is available any time the
                    component changes
                  </li>
                </ul>
              </li>
              <li>
                Setting this to true indicates that the ViewChild is "static"
                content and always available on the page
                <ul>
                  <li>
                    This will tell Angular that the ViewChild is available at
                    anytime
                  </li>
                  <li>
                    It will query for the ChildComponent at the earliest
                    lifecycle hook availabe and then never query again
                  </li>
                  <li>
                    Must wait for ngAfterViewInit lifecycle hook at the earliest
                    since its the first lifecycle that runs after
                    ChangeDetection for the component
                  </li>
                </ul>
              </li>
              <li>
                Use the following rules to determine the Setting
                <ul>
                  <li>
                    If the ChildComponent is hidden or dynamicaly loaded in some
                    way via component binding (either property binding or API
                    call), it must have false
                  </li>
                  <li>
                    If the ChildComponent is always available on the page and it
                    is never hidden, then it can be true or false.
                  </li>
                  <li>
                    Setting it to false is more performant and gives you access
                    to the component earlier
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            The ViewChild decorator can only see elements in the component’s
            template
            <ul>
              <li>It cannot see across component boundaries</li>
              <li>
                Cannot see elements in the component’s parent or in any of its
                child components
              </li>
            </ul>
          </li>
          <li>
            ViewChild when using a template reference name has this default
            behavior
            <ul>
              <li>
                When injecting a reference applied to a component, you get back
                the component instance
              </li>
              <li>
                When injecting a reference to a plain HTML element, you get back
                the corresponding wrapped DOM element
              </li>
            </ul>
          </li>
        </ul>
        <div>
          To get a child component (most common use)
          <ol>
            <li>
              Tag the element with a template variable
              <div class="card">
                <div class="card-body">
                  <code> &lt;my-element #componentToRef ...</code>
                </div>
              </div>
            </li>
            <li>
              Add a property named after the template variable to the component
              and decorate it with the ViewChild decorator (decorator takes the
              class of the of the component). Any reference must occur in the
              AfterViewInit lifecycle hook.
              <div class="card">
                <div class="card-body">
                  <code>
                    @ViewChild(MyElementComponent) componentToRef:
                    MyElementComponent
                  </code>
                </div>
              </div>
            </li>
          </ol>
        </div>
        <div>
          You can inject a reference to a DOM element. Use this option when you
          want to work with an HTML element in the component template (for
          example, if you need to make some jQuery calls to an element)
          <ul>
            <li>
              Tag the element with a template variable
              <div class="card">
                <div class="card-body"><code> &lt;h2 #title ...</code></div>
              </div>
            </li>
            <li>
              Add a ViewChild property and decorate it with the ViewChild
              (decorator takes the template variable as a string)
              <div class="card">
                <div class="card-body">
                  <code
                    >@ViewChild(&quot;title&quot;)&#10;title: ElementRef</code
                  >
                </div>
              </div>
            </li>
            <li>
              Use the nativeElement property on the ElementRef object to get the
              native DOM element
              <ul>
                <li>this.title.nativeElement</li>
                <li>ElementRef is a wrapper class for the DOM element</li>
              </ul>
            </li>
          </ul>
        </div>
        <div>
          <p>
            To inject a reference to a child component, but get the actual DOM
            object instead of the component object
          </p>
          <div class="card">
            <div class="card-body">
              <code>
                @ViewChild(MyElementComponent, {read:
                ElementRef})&#10;componentToRef: MyElementComponent
              </code>
            </div>
          </div>
        </div>
        <div>
          <p>
            To inject a reference to a directive, tag the element with the
            targeted directive with a template variable
          </p>
          <div class="card">
            <div class="card-body">
              <code>
                &lt;input #primaryInput
                &#91;(colorPicker)&#93;&quot;primary&quot;
                &#91;(ngModel)&#93;=&quot;primary&quot;/&gt;
              </code>
            </div>
          </div>
          <p>
            Add a property named after the directive to the component and
            decorate it with the ViewChild decorator (decorator takes the string
            of the template variable and a configuration object specifying the
            type of directive)
          </p>
          <div class="card">
            <div class="card-body">
              <code>
                @ViewChild(&quot;primaryInput&quot;, {read:
                ColorPickerDirective})&#10;colorPicker: ColorPickerDirective;
              </code>
            </div>
          </div>
        </div>
        <div>
          Links
          <ul>
            <li>
              <a
                href="https://tutorialsforangular.com/2021/06/20/what-does-the-static-property-on-viewchild-do/"
                target="_blank"
                >https://tutorialsforangular.com/2021/06/20/what-does-the-static-property-on-viewchild-do/</a
              >
            </li>
          </ul>
        </div>
      </section>
    </div>
    <script src="./assets/bootstrap/js//bootstrap.bundle.js"></script>
  </body>
</html>
