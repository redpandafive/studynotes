<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Index</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
    <link rel="stylesheet" href="../assets/bootstrap/css/bootstrap.min.css" /><link rel="stylesheet" href="./assets/styles/site.css" />
  </head>
  <body><nav class="navbar navbar-expand-lg bg-light"><div class="container-fluid"><a class="navbar-brand" href="../">Home</a></div></nav>
    <div class="container">
      <h1>Methods and Functions</h1><section class="navlinks"><ul><li><a href="./angular/angularcli.html#commands">Commands</a></li></ul></section>
      <section>
        <ul>
          <li>Code block that contains a series of statements</li>
          <li>
            In C#, every executed instruction is performed in the context of a
            method
            <ul>
              <li>Every C# application’s entry point is the Main method</li>
            </ul>
          </li>
        </ul>
      </section>

      <h2>Higher-Order Functions</h2>
      <section>
        <ul>
          <li>
            A function that takes one or more functions as arguments, or returns
            a function, or both
          </li>
          <li>
            Done with
            <ul>
              <li>
                Delegates
                <ul>
                  <li>
                    Type that represent a reference to a method with particular
                    parameters and a return type
                  </li>
                </ul>
              </li>
              <li>
                Lambda expressions
                <ul>
                  <li>Used to create delegates or expression tree types</li>
                  <li>Common place they are used in LINQ</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </section>

      <h2>Extension Methods</h2>
      <section>
        <ul>
          <li>
            Allows you to “add” methods to existing types without creating a new
            derived type pr modifying the original type
            <ul>
              <li>Can extend a class or interface, but not override them</li>
              <li>
                If an extension method is used with a class and they have
                matching method names, the class version has priority
              </li>
            </ul>
          </li>
          <li>
            Static methods
            <ul>
              <li>
                However, they are called as if they were instance methods on the
                extended type
              </li>
              <li>
                Syntactically identical to calling a built-in method on the type
              </li>
            </ul>
          </li>
          <li>
            Do not break encapsulation since they cannot access private fields
            in the type they are extending
          </li>
          <li>
            Commonly used a LINQ standard query operators that add functionality
            to existing IEnumerable types
          </li>
          <li>
            Common usage patterns
            <ul>
              <li>
                Collection functionality
                <ul>
                  <li>
                    Replaces “collection classes” that implement
                    IEnumerable&gt;T&lt; to add functionality that acted on
                    collections of that type
                  </li>
                  <li>
                    Same effect can be done by adding extension methods to the
                    IEnumerable&gt;T&lt; interface
                  </li>
                </ul>
              </li>
              <li>
                Layer specific functionality
                <ul>
                  <li>
                    Can add functionality to an object that is specific to an
                    application layer
                  </li>
                  <li>
                    Does not load an object down with methods not needed or
                    wanted in other layers
                  </li>
                </ul>
              </li>
              <li>
                Extending predefined types
                <ul>
                  <li>
                    Alternative to creating new objects to extend existing types
                    (including built ins)
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            To define
            <ul>
              <li>
                Create a static class containing the method that is visible to
                the client
              </li>
              <li>Method should be static</li>
              <li>
                First parameter is the type that the method will operate on
                <ul>
                  <li>Preceded with the <code>this</code> modifier</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            Can also be defined
            <ul>
              <li>As an extension property</li>
              <li>To an enumeration type</li>
              <li>
                Can reference static properties within the extension class
              </li>
            </ul>
          </li>
          <li>
            To create one
            <ul>
              <li>Create a static class</li>
              <li>Add a static method</li>
              <li>
                The first parameter of this method should be of the type you
                want to extend
              </li>
              <li>
                Prefix this first parameter with the <kbd>this</kbd> keyword
              </li>
            </ul>
          </li>
        </ul>
      </section>

      <h2>Parameters vs Arguments</h2>
      <section>
        <ul>
          <li>
            Parameters
            <ul>
              <li>defined on the method signature</li>
              <li>specifying the name and types</li>
            </ul>
          </li>
          <li>
            Arguments
            <ul>
              <li>Concrete values passed by code when it calls a method</li>
              <li>Must be compatible with the parameter type</li>
            </ul>
          </li>
        </ul>
      </section>

      <h2>Parameters</h2>
      <section>
        <ul>
          <li>
            Out Parameters
            <ul>
              <li>
                In newer versions of C#, out paraemters can be declared inline
              </li>
              <li>Scope will be the next biggest scope (surrounding scope)</li>
            </ul>
            <div class="card"><div class="card-body"><code> out int staffCount"</code></div></div>
          </li>
        </ul>
      </section>

      <h2>Argument Types</h2>
      <section>
        <ul>
          <li>
            Positional
            <ul>
              <li>
                Arguments match the order of parameters in the method signature
              </li>
            </ul>
            <div class="card"><div class="card-body"><code>
              code='PrintOrderDetails("Gift Shop", 21, "Red Mug")'
            </code></div></div>
          </li>
          <li>
            Named
            <ul></ul>
          </li>
          <li>Prefix argument values with a parameter name</li>
          <li>No longer have to match the parameter order of the signature</li>
          <li>
            Example – these two work the same
            <div class="card"><div class="card-body"><code>
              code='PrintOrderDetails(seller: "Gift Shop", order: 21, product "Red Mug");&#10;PrintOrderDetails(order: 21, product "Red Mug", seller: "Gift Shop");'
            </code></div></div>
          </li>
          <li>
            Can be combined with positional arguments
            <ul>
              <li>Named arguments should follow positional arguments</li>
            </ul>
            <div class="card"><div class="card-body"><code>
              code='PrintOrderDetails("Gift Shop", 31, product: "Red Mug");'
            </code></div></div>
          </li>
          <li>
            Starting with C# 7.2, positional arguments only have to be in the
            correct position
          </li>
          <li>
            Positional arguments cannot follow any out of order named arguments
          </li>
        </ul>
      </section>

      <h2>Optional Arguments</h2>
      <section>
        <ul>
          <li>
            When a parameter is optional, the caller can omit those arguments
            <ul>
              <li>
                Default value defined in the signature will be used instead
              </li>
            </ul>
          </li>
          <li>Must be defined at the end of the signature</li>
          <li>
            If there are multiple default arguments, the caller cannot use comma
            separated gaps to skip an argument, but provide one that follows
            <ul>
              <li>Use named arguments as a workaround if this must be done</li>
            </ul>
          </li>
        </ul>
      </section>

      <h2>Passing by Reference vs Passing by Value</h2>
      <section>
        <ul>
          <li>
            Value types are passed by value
            <ul>
              <li>
                A copy of its data is passed to the method instead of the
                instance itself
              </li>
              <li>Use the ref keyword to pass a value type by reference</li>
              <li>
                If you pass it to a method, the only way to change it within the
                method (and be reflected in the caller) is to use the ref or out
                keyword
              </li>
            </ul>
          </li>
          <li>
            Reference types
            <ul>
              <li>
                A reference to the object is passed instead of a copy of it
              </li>
              <li>
                Changes inside the method will be reflected in the calling code
              </li>
              <li>
                Don’t have to return a reference type that was passed to a
                method, but you can for good style or functional flow of values
              </li>
            </ul>
          </li>
          <li>
            Example of passing an array by reference
            <ul>
              <li>Passing an array to a function is passed by reference</li>
              <li>
                Modifying an element in the array will be reflected in the
                caller
              </li>
              <li>
                If you assign a new array to the variable using the new keyword,
                a new array in a different part of memory will be created
                <ul>
                  <li>
                    Within the function, the parameter will reference this new
                    array
                  </li>
                  <li>
                    In the called, the parameter will reference the previous
                    array
                  </li>
                </ul>
              </li>
              <li>
                If you add the ref keyword to the parameter, then assigning a
                new array to the passed parameter will be reflected in the
                caller
              </li>
            </ul>
          </li>
        </ul>
      </section>

      <h2>Ref Keyword</h2>
      <section>
        <ul>
          <li>C# 7 feature</li>
          <li>
            Allows you to pass things by reference and (as of C#7) return them
            by reference and store them by reference in local variables
          </li>
          <li>
            Can be valuable when you need to go into a massive array and make
            some changes and return it from the function
          </li>
          <li>
            Must use ref keyword a lot since they really want you to make sure
            you know you are doing this
            <ul>
              <li>
                Method signature must contain the ref keyword
                <div class="card"><div class="card-body"><code>
                  public ref double GetEstimatedDistaince() ..."
                </code></div></div>
              </li>
              <li>
                Return statement must use the ref keyword too
                <div class="card"><div class="card-body"><code>
                  return ref estDistance;"
                </code></div></div>
              </li>
              <li>
                Variable you assign the results into must contain the ref
                keyword
                <div class="card"><div class="card-body"><code>
                  ref instance = Planet.GetEstimatedDistance();"
                </code></div></div>
              </li>
            </ul>
          </li>
        </ul>
      </section>

      <h2>Local Functions</h2>
      <section>
        <ul>
          <li>Added in C#7</li>
          <li>
            Same thing as nested functions, or functions that contain other
            functions
          </li>
          <li>
            A method that sites inside of another method
            <ul>
              <li>Can’t pass outside the containing method</li>
              <li>Cannot capture into a variable</li>
              <li>Executes within the containing scope</li>
            </ul>
          </li>
          <li>
            These can be used anywhere within the parent function
            <ul>
              <li>Can be called before and after declaration</li>
              <li>
                Recommend you put them at the end of the containing method
              </li>
            </ul>
          </li>
          <li>
            Let you get away from delegates and lambdas in several cases
            <ul>
              <li>
                However, you cannot pass references to the function around
              </li>
              <li>
                Don’t have to put a delegate on the heap, declare the delegate,
                and is faster
              </li>
            </ul>
          </li>
          <li>
            Useful in place of
            <ul>
              <li>Lambdas</li>
              <li>Delegates</li>
              <li>Recursive functions</li>
              <li>
                Async methods where you need to do some validation before firing
                it
              </li>
            </ul>
          </li>
          <li>
            Definition
            <ul>
              <li>Modifiers = Async, unsafe, static, extern</li>
              <li>Return type</li>
              <li>Method name</li>
              <li>Parameter list</li>
            </ul>
          </li>
          <li>
            These are private methods - definition cannot not include a member
            access modifier
          </li>
        </ul>
      </section>
    </div>
    <script src="../assets/bootstrap/js/bootstrap.bundle.js"></script>
  </body>
</html>
