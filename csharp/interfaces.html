<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Index</title>
    <base href="/" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
    <link rel="stylesheet" href="./assets/bootstrap/css/bootstrap.min.css" /><link rel="stylesheet" href="./assets/styles/site.css" />
  </head>
  <body><nav class="navbar navbar-expand-lg bg-light"><div class="container-fluid"><a class="navbar-brand" href="./">Home</a></div></nav>
    <div class="container">
      <h1>Interfaces</h1><section class="navlinks"><ul><li><a href="./angular/angularcli.html#commands">Commands</a></li></ul></section>

      <section>
        <ul>
          <li>
            Classes that implement multiple interfaces can be assigned to
            variables typed to each of those interfaces
            <ul>
              Class SampleClass that implements IControl and ISurface can be
              assigned to variables typed as IControl and variables typed as
              ISurface
            </ul>
          </li>
        </ul>
      </section>

      <h2>Default Interface Methods</h2>
      <section>
        <ul>
          <li>Added in C# 8</li>
          <li>
            Defines an implementation when you declare a member of an interface
            <ul>
              <li>
                If you need different behavior, you can override it when
                implanting the class
              </li>
            </ul>
          </li>
          <li>
            Common scenario is to safely add members to an interface already
            released and used by clients (that you cannot change)
            <ul>
              <li>
                Interfaces are immutable once they have been released since any
                change to it will be a breaking change to the client
              </li>
              <li>
                This allows you to add new members to the interface without
                forcing existing clients to implement them
              </li>
            </ul>
          </li>
          <li>
            Interfaces can include static members, including fields and methods
            <ul>
              <li>These can have a access modifier applied as well</li>
              <li>
                Can use this to add a default method to an interface as well as
                a “configuration” static method
              </li>
              <li>
                This configuration method would set static private values on the
                interface
              </li>
              <li>
                The default method could then reference these static fields to
                do the necessary work
              </li>
            </ul>
          </li>
        </ul>
      </section>

      <h2>Explicit Interface Implementations</h2>
      <section>
        <ul>
          <li>
            Use when a class implements multiple interfaces that contain a
            member with the same signature
          </li>
          <li>
            Default is to cause the class to implement a single method for both
            interfaces
            <ul>
              <li>
                For instance, if a class implements two class with a method
                Paint with the same signature, then the implemented class will
                have one Paint method that satisfies both contracts
              </li>
            </ul>
          </li>
          <li>
            If you need to be able to reference each method separately, you can
            use an explicit interface member
            <ul>
              <li>
                Sample class would implement two methods
                <ul>
                  <li>Void IControl.Paint()…</li>
                  <li>Void ISurface.Paint()…</li>
                </ul>
              </li>
              <li>
                Calling the Paint method from a variable typed as IControl would
                automatically call the IControl.Paint method
              </li>
              <li>
                Calling the Paint method from a variable typed as ISurface would
                automatically call the ISurface.Paint method
              </li>
            </ul>
          </li>
          <li>
            This can also be used if two interfaces have members with the same
            name, but are different things, such as a property or method
          </li>
          <li>
            To call any method declared and implemented on the interface, a
            variable must be the type of the interface, not the class
          </li>
        </ul>
      </section>
    </div>
    <script src="./assets/bootstrap/js/bootstrap.bundle.js"></script>
  </body>
</html>
