<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Index</title>
    <base href="/" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
    <link rel="stylesheet" href="./assets/bootstrap/css/bootstrap.min.css" /><link rel="stylesheet" href="./assets/styles/site.css" />
  </head>
  <body><nav class="navbar navbar-expand-lg bg-light"><div class="container-fluid"><a class="navbar-brand" href="./">Home</a></div></nav>
    <div class="container">
      <h1>Assorted Topics</h1><section class="navlinks"><ul><li><a href="./angular/angularcli.html#commands">Commands</a></li></ul></section>

      <!-- linkMappings: AnchorLinkMapping[] = [
{ id: "closures", label: "Closures" },
{ id: "discards", label: "Discards" },
{ id: "using", label: "Using Directive" },
{ id: "debugging", label: "Debugging" },
{ id: "eventHandlers", label: "Event Handlers" },
{ id: "nameOf", label: "NameOf Expressions" },
{ id: "namespaces", label: "Namespaces" },
{ id: "with", label: "With Expressions" },
{ id: "yieldReturn", label: "Yield Return" },
];
} -->

      <h2 id="closures">Closures</h2>
      <section>
        <ul>
          <li>
            Think of it as a set of data associated with a function
            <ul>
              <li>
                Think of an object as a set of methods associated with data
              </li>
            </ul>
          </li>
          <li>
            This may be an alternative to some problems rather a
            larger-than-necessary OO solution
          </li>
          <li>
            Use lambda expressions to implement closures in C#
            <ul>
              <li>
                Lambda expressions can “capture” variables in the outer method
                and reference them
              </li>
              <li>
                These variables are not garbage collected until all references
                are done, include the underlying Delegate that is constructed
                under the hood with lambdas
              </li>
            </ul>
          </li>
        </ul>
      </section>

      <h2 id="discards">Discards</h2>
      <section>
        <ul>
          <li>
            Placeholder variable that are intentionally unused in application
            code
            <ul>
              <li>Do not contain a value</li>
              <li>This communicates intent to others that read your code</li>
              <li>
                also called write-only, you cannot read the value from this
                parameter
              </li>
            </ul>
          </li>
          <li>
            Can be used in
            <ul>
              <li>Results returned from an expression</li>
              <li>One or more members of a tuple expression</li>
              <li>An out parameter to a method</li>
              <li>Tuple deconstruction for fields you do not intent to use</li>
              <li>
                Switch expressions – this will match anything, including null
              </li>
              <li>
                Ignore a Task object were you don’t need to handle exceptions
              </li>
              <li>Input parameters of a lambda expression (C# 9)</li>
            </ul>
          </li>
          <li>Use the underscore character to represent this</li>
          <li>
            Example
            <div class="card"><div class="card-body"><code>
              if(int.TryParse(ReadLine(), out int _)"
            </code></div></div>
          </li>
        </ul>
      </section>

      <h2 id="using">Using Directive</h2>
      <section>
        <ul>
          <li>
            A using directive can be used to automatically call the Dispose
            method
            <ul>
              <li>This ensures the correct use of IDisposable objects</li>
              <li>
                Ensures Dispose will be classed even if an exception occurs
              </li>
            </ul>
          </li>
          <li>
            For instance, rather than explicitly closing an open SQL connection,
            you can surround it with a using directive to have that done
            automatically
          </li>
          <li>
            Pre C# 8
            <ul>
              <li>
                Should declare and instantiate within the using statement so the
                Dispose methos is automatically called and the object goes out
                of scope at the same time
              </li>
              <li>
                Multiple instances can be declared in a single using statement
                using a comma separated list
              </li>
            </ul>
            <div class="card"><div class="card-body"><code>
              using(var reader = new StringReader(manyLines)) {...}"
            </code></div></div>
          </li>
          <li>
            C# 8
            <ul>
              <li>Curly braces and parentheses are no longer needed</li>
            </ul>
            <div class="card"><div class="card-body"><code>
              using(var reader = new StringReader(manyLines)) {...}"
            </code></div></div>
          </li>
        </ul>
      </section>

      <h2 id="debugging">Debugging</h2>
      <section>
        <ul>
          <li>
            Run to click
            <ul>
              <li>
                If you are stopped at a breakpoint, you can hover of just to the
                left of any line of code
              </li>
              <li>Pressing the green arrow will run to that point</li>
            </ul>
          </li>
          <li>
            Run to cursor
            <ul>
              <li>Right click to execute to the cursor position</li>
            </ul>
          </li>
          <li>
            Null reference analysis
            <ul>
              <li>
                Popup for NullReferenceExceptions will display the variable name
                that caused the exception
              </li>
            </ul>
          </li>
        </ul>
      </section>

      <h2 id="eventHandlers">Event Handlers</h2>
      <section>
        <ul>
          <li>Nothing more than methods that are invoked through delegates</li>
        </ul>
      </section>

      <h2 id="nameOf">NameOf Expressions</h2>
      <section>
        <ul>
          <li>
            Returns the name of a variable, type, or member as as a string
            constant
          </li>
          <li>Name is not fully qualified</li>
          <li>
            The following prints "ZipCode"
            <div class="card"><div class="card-body"><code>
              WriteLine(nameof(persion.Address.ZipCode))"
            </code></div></div>
          </li>
          <li>Useful for printing exceptions and the offending element</li>
          <li>Added in C# 6</li>
        </ul>
      </section>

      <h2 id="namespaces">Namespaces</h2>
      <section>
        <ul>
          <li>
            The using directive allows you to use types defined in a namespace
            without specifying the fully qualified namespace of that type
          </li>
          <li>
            Does not give you access to any namespaces that are nested in the
            namespace you specify
          </li>
          <li>
            Example
            <ul>
              <li>
                <code>using System.Text</code>
              </li>
              <li>
                This imports all the types from the single namespace
                (System.Text)
              </li>
            </ul>
          </li>
          <li>
            There are two types
            <ul>
              <li>User defined – namespaces defined in your code</li>
              <li>System defined – namespaces defined in the framework</li>
            </ul>
          </li>
          <li>
            Using alias directive
            <ul>
              <li>
                Example
                <div class="card"><div class="card-body"><code>
                  using Project = PC.MyCompany.Project;"
                </code></div></div>
              </li>
              <li>
                Makes it easier to qualify an identifier to a namespace or type
              </li>
              <li>
                Cannot use a using alias in the declaration of a using directive
              </li>
            </ul>
          </li>
          <li>
            Global modifier
            <ul>
              <li>
                Prefix a using directive with the keyword global to apply the
                using to all files in the compilation
              </li>
              <li>Added in C# 10</li>
              <li>
                Example
                <div class="card"><div class="card-body"><code> global using System.Text"</code></div></div>
              </li>
              <li>
                Restrictions
                <ul>
                  <li>Can appear the beginning of any source code file</li>
                  <li>Order does not matter</li>
                  <li>
                    Must appear before all using directives without the global
                    keyword
                  </li>
                  <li>
                    Must appear before all namespace and type declarations in
                    the file
                  </li>
                  <li>Typically keep in a single location</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            Static modifier
            <ul>
              <li>
                Allows you to access static members of a type without specifying
                the type name
              </li>
              <li>
                Doesn’t matter if there are also instance members on the same
                type
              </li>
              <li>
                Example
                <ul>
                  <li>
                    You can now just write WriteLine instead of System.WriteLine
                  </li>
                </ul>
                <div class="card"><div class="card-body"><code> using static System.Console"</code></div></div>
              </li>
              <li>
                Restrictions
                <ul>
                  <li>Does not import inherited members</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </section>

      <h2 id="with">With Expressions</h2>
      <section>
        <ul>
          <li>
            Use to create a new object from another by specifying the properties
            that should change
          </li>
          <li>All others will have their values copied over</li>
          <li>Useful when you are working with immutable objects</li>
          <li>
            Example
            <div class="card"><div class="card-body"><code>
              var newProduct = product with { CategoryId = 2 };"
            </code></div></div>
          </li>
        </ul>
      </section>

      <h2 id="yieldReturn">Yield Return</h2>
      <section>
        <ul>
          <li>
            Use within
            <ul>
              <li>
                a method that returns an IEnumerable&lt;type&gt; where type is
                the type of data being returned (an individual item in the
                collection, not the entire collection)
              </li>
              <li>an iterator</li>
            </ul>
          </li>
          <li>
            Returns a individual value for each turn of the iterator without
            existing the method
            <ul>
              <li>
                Values are returned one at a time, so should be used within an
                iterator on the caller
              </li>
              <li>
                Eliminates the need to create a temporary collection to store
                data before it is returned
              </li>
              <li>
                Control is returned to the caller each time the yield return
                statement is encountered and executed
              </li>
              <li>
                This preserves the callee's state information so that execution
                can continue immediately after the yield statement when the
                control returns
              </li>
            </ul>
          </li>
          <li></li>
          <li>
            There are two possible uses of the yield keyword
            <ul>
              <li>yield return</li>
              <li>
                yield break
                <ul>
                  <li>Use to terminate the enumeration</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            Really just syntax sugar
            <ul>
              <li>
                Returns an object that implements the IEnumerable interface
              </li>
              <li>
                Under the hood it creates a state machine to maintain state
                information
              </li>
            </ul>
          </li>
          <li>
            Benefits
            <ul>
              <li>
                Do not need a temporary collection to hold values generated
                within an iterator
              </li>
              <li>
                Items that are returned are created only on demand
                <ul>
                  <li>
                    You could add a conditional within the iterator block to
                    yield return only if certain conditions are true
                  </li>
                </ul>
              </li>
              <li>
                Useful situations
                <ul>
                  <li>
                    Generating a sequence of strings where each string in the
                    sequence depends on the value of the previous string
                  </li>
                </ul>
              </li>
              <li>
                Processing a text file sequentially where different kinds of
                lines are treated differently
              </li>
              <li>
                Sequentially filtering or modifying a large List collection of
                objects
              </li>
            </ul>
          </li>

          <li>
            Downsides
            <ul>
              <li>
                Generates a state machine under the hood. It returns a promise
                to generate points later if asked (iterated over)
                <ul>
                  <li>
                    This can cause an unexpected problem if you assume the value
                    returned by the method containing it is a straight up
                    IEnumerable
                    <ul>
                      <li>
                        Example is assigning the results to a variable without
                        performing an iteration
                      </li>
                    </ul>
                  </li>
                  <li>
                    This can be fixed by assigning a call ToList() after the
                    method call
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </section>
    </div>
    <script src="./assets/bootstrap/js//bootstrap.bundle.js"></script>
  </body>
</html>
